<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GDB调试学习总结</title>
    <url>/2021/09/15/GDB/</url>
    <content><![CDATA[<h1 id="GDB调试学习总结"><a href="#GDB调试学习总结" class="headerlink" title="GDB调试学习总结"></a>GDB调试学习总结</h1><h2 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h2><table>
<thead>
<tr>
<th>命令名称</th>
<th>命令缩写</th>
<th>命令说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td>r</td>
<td>运行一个程序</td>
<td></td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>添加断点</td>
<td>-b xx.cpp:line</td>
</tr>
<tr>
<td>delete</td>
<td>del</td>
<td>删除断点</td>
<td></td>
</tr>
<tr>
<td>list</td>
<td>l</td>
<td>显示源代码</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>让暂停的程序继续运行</td>
<td></td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>运行到下一行源代码，不进入函数内部</td>
<td></td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>运行到下一行源代码，进入函数内部</td>
<td></td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印变量或者寄存器的值</td>
<td></td>
</tr>
<tr>
<td>until</td>
<td>u</td>
<td>运行到指定行停止下来</td>
<td></td>
</tr>
<tr>
<td>jump</td>
<td>j</td>
<td>将当前程序执行流跳转到指定行或地址</td>
<td></td>
</tr>
<tr>
<td>backtrace</td>
<td>bt</td>
<td>查看当前线程的调用堆栈</td>
<td></td>
</tr>
<tr>
<td>thread</td>
<td>thread</td>
<td>切换到指定线程</td>
<td></td>
</tr>
<tr>
<td>frame</td>
<td>f</td>
<td>切换到当前调用线程的指定堆栈,具体堆栈通过堆栈序号指定</td>
<td></td>
</tr>
<tr>
<td>info</td>
<td>info</td>
<td>查看断点/线程等信息</td>
<td></td>
</tr>
<tr>
<td>ptype</td>
<td>ptype</td>
<td>查看变量类型</td>
<td></td>
</tr>
<tr>
<td>disassemble</td>
<td>dis</td>
<td>查看汇编代码</td>
<td></td>
</tr>
<tr>
<td>watch</td>
<td>watch</td>
<td>监视某一个变量或内存地址的值是否发生变化</td>
<td></td>
</tr>
<tr>
<td>finish</td>
<td>fin</td>
<td>结束当前调用函数，返回到上一层函数调用处</td>
<td></td>
</tr>
<tr>
<td>return</td>
<td>return</td>
<td>结束当前调用函数并返回指定值，到上一层函数调用处</td>
<td></td>
</tr>
</tbody></table>
<h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><h3 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h3><ul>
<li><code>gdb filename</code><br>开发过程中，编译生成目标二进制文件后，可以直接<code>gdb filename</code>开始调试，输入<code>run</code>或<code>r</code>运行程序。比如下图所示：<br>  <img src="/2021/09/15/GDB/gdb1.png" alt="gdb1"><br>启动后可以通过<code>netstat -nltp | grep 6379</code>来查看程序已经运行起来了<br>  <img src="/2021/09/15/GDB/gdb2.png" alt="gdb2"></li>
</ul>
<h3 id="附加进程调试"><a href="#附加进程调试" class="headerlink" title="附加进程调试"></a>附加进程调试</h3><ul>
<li><code>gdb attach pid</code><br>如果当程序已经启动后想调试，但是不想重启程序。或者当程序在测试过程中，不能重启，一旦重启则会丢失当前的状态信息。这种情况下就使用附加进程进行调试。<ul>
<li>获取进程pid<br><img src="/2021/09/15/GDB/gdb3.png" alt="gdb3"></li>
<li>生成附加进程<br><img src="/2021/09/15/GDB/gdb4.png" alt="gdb4"><br>提示 “Attaching to process 8380 时即已成功将 GDB 附加到目标进程，结束调试后输入<code>detach</code>离开且不对当前进程有影响，让程序和gdb调试器分离，如下图：<br><img src="/2021/09/15/GDB/gdb5.png" alt="gdb5"></li>
</ul>
</li>
</ul>
<h3 id="core文件调试"><a href="#core文件调试" class="headerlink" title="core文件调试"></a>core文件调试</h3><p>coredump即核心转储，是进程运行崩溃瞬间的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存到core文件，该文件是个二进制文件，可以使用gdb进行分析。</p>
<ul>
<li><p>产生原因</p>
<ul>
<li>内存访问越界</li>
<li>多线程程序使用了线程不安全的函数</li>
<li>多线程读写数据未加锁保护，对于被多个线程同时访问的全局数据，要加锁保护否则会coredump</li>
<li>非法指针</li>
<li>堆栈溢出</li>
</ul>
</li>
<li><p>查看系统产生core文件后存放的位置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xw@null coredump]$ cat /proc/sys/kernel/core_pattern </span><br><span class="line">/data/coredump/core_%e_%t</span><br><span class="line">- 表示产生的core文件都以core_%e_%t格式保存到/data/coredump/目录下</span><br><span class="line">-e 程序文件名</span><br><span class="line">-t 时间戳</span><br><span class="line">-p 进程ID</span><br><span class="line">-s 使进程崩溃的信号signal</span><br></pre></td></tr></table></figure></li>
<li><p>修改core文件的存储位置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;/data/coredump/core_%e_%t&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></li>
<li><p>修改core文件大小<br>  (1) ulimit -c 查看参数core file size的值，如果为0表示不会生成core文件，一般修改为unlimited</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xw@null ~]$ ulimit -c</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>  (2) 修改core文件大小</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xw@null ~]$ ulimit -c unlimited</span><br><span class="line">[xw@null ~]$ ulimit -c</span><br><span class="line">unlimited</span><br></pre></td></tr></table></figure></li>
<li><p><code>readelf -h corefile</code>查看core文件头<br>  <img src="/2021/09/15/GDB/core8.png" alt="core8"></p>
</li>
<li><p>gdb调试core文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb 执行文件 core文件</span><br><span class="line">where/bt 查看堆栈信息进一步分析程序</span><br></pre></td></tr></table></figure></li>
<li><p>参考链接</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/98700797">linux coredump调试</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46605905">gdb调试coredump</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/199841770">linux上创建并调试转储文件</a></li>
</ul>
</li>
</ul>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxxx@gzqc-172_24_21_96-null src]$ gdb redis-server</span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/15/GDB/gdb6.png" alt="gdb6"><br>此时只是附加了一个调试文件，程序还未启动，输入<code>run</code>命令即可运行程序。<br><img src="/2021/09/15/GDB/gdb7.png" alt="gdb7"><br>按<code>Ctrl+C</code>可以中断<code>gdb</code>,再次输入<code>r</code>后输入<code>y</code>重启程序<br><img src="/2021/09/15/GDB/gdb8.png" alt="gdb8"></p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>按<code>Ctrl+C</code>可以中断<code>gdb</code>,输入<code>c</code>可以使程序继续运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff71e9d43 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul>
<li><p><code>break</code>用于添加断点，添加完成后重启程序即可触发，停在断点处</p>
<ul>
<li><code>break func</code>在函数名入口处添加断点 </li>
<li><code>break line</code>在当前文件行号line处添加断点</li>
<li><code>break filename:line</code>在文件filename行号line处添加断点<br><img src="/2021/09/15/GDB/gdb9.png" alt="gdb9"></li>
</ul>
</li>
<li><p>redis-server端口<code>6379</code>，端口号肯定是通过<code>bind()</code>函数创建的，搜索文件位于<code>anet.c 401 </code>行。<br>  <img src="/2021/09/15/GDB/gdb10.png" alt="gdb10"></p>
<ul>
<li>在<code>anet.c:401</code>处添加断点后重启触发断点<code>1</code>, <code>continue</code>后触发断点<code>2</code>。如下所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b anet.c:401</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /data/home/xxxx/redis-6.2.3/src/redis-server </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.</span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdf58) at server.c:6151</span><br><span class="line">6151        char config_from_stdin = 0;</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 2, anetListen (err=0xbcee50 &lt;server+752&gt; &quot;&quot;, s=10, sa=0xdf79a0, len=16, backlog=511) at anet.c:401</span><br><span class="line">401         if (bind(s,sa,len) == -1) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>分别在<code>anet.c 404 410 412</code>处添加断点，用于判断从该函数从何处返回。如下图所示：<br><img src="/2021/09/15/GDB/gdb12.png" alt="gdb12"></li>
<li><code>continue</code>可以看到触发断点<code>5</code>。如下图所示：<br><img src="/2021/09/15/GDB/gdb13.png" alt="gdb13"></li>
</ul>
</li>
</ul>
<h3 id="backtrace-和-frame"><a href="#backtrace-和-frame" class="headerlink" title="backtrace 和 frame"></a>backtrace 和 frame</h3><ul>
<li><p><code>backtrace</code>用于查看堆栈信息。<code>frame</code>用于切换到某个堆栈处。上面的gdb程序中断在<code>anet.c:412</code>处</p>
<ul>
<li><p><code>bt</code>查看此时的堆栈信息共有6层堆栈<code>#0 ~ #5</code>，如下图所示：<br><img src="/2021/09/15/GDB/gdb15.png" alt="gdb15"></p>
</li>
<li><p><code>frame 堆栈编号</code>切换堆栈信息，如下图所示：<br><img src="/2021/09/15/GDB/gdb14.png" alt="gdb14"><br>  可以得到调用关系</p>
<ul>
<li><code>main()</code>函数在6322行调用<code>initServer()</code>函数</li>
<li><code>initServer()</code>函数在3195行调用<code>listenToPort()</code>函数</li>
<li><code>listenToPort()</code>函数在3052行调用<code>anetTcpServer()</code>函数</li>
<li><code>anetTcpServer()</code>函数在468行调用<code>_anetTcpServer()</code>函数</li>
<li><code>_anetTcpServer()</code>函数在450行调用<code>anetListen()</code>函数</li>
<li>此时断点正停在<code>anetListen()</code>函数中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="info-break、enable、disable、delete"><a href="#info-break、enable、disable、delete" class="headerlink" title="info break、enable、disable、delete"></a>info break、enable、disable、delete</h3><ul>
<li><code>info b</code>查看断点个数<br>  <img src="/2021/09/15/GDB/gdb16.png" alt="gdb16"></li>
<li><code>enable num</code>启用编号为num的断点，不加参数表示全部启用</li>
<li><code>disable num</code>禁用编号为num的断点，不加参数表示全部禁用</li>
<li><code>delete num</code>删除编号为num的断点，不加参数表示全部删除  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">3       breakpoint     keep y   0x000000000043412c in anetListen at anet.c:404</span><br><span class="line">4       breakpoint     keep y   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) disable 4</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">3       breakpoint     keep y   0x000000000043412c in anetListen at anet.c:404</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) delete 3</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) disable </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep n   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep n   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) enable </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep y   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) delete </span><br><span class="line">Delete all breakpoints? (y or n) y       </span><br><span class="line">(gdb) info b</span><br><span class="line">No breakpoints or watchpoints.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul>
<li><code>list</code>用于显示源码，默认显示10行。如图所示：<br>  <img src="/2021/09/15/GDB/gdb17.png" alt="gdb17"></li>
</ul>
<h3 id="print、ptype"><a href="#print、ptype" class="headerlink" title="print、ptype"></a>print、ptype</h3><ul>
<li><code>print</code>用于查看变量的值，<code>ptype</code>用于查看变量类型。如下所示：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) f 4</span><br><span class="line">#4  0x000000000043b304 in initServer () at server.c:3195</span><br><span class="line">3195            listenToPort(server.port,&amp;server.ipfd) == C_ERR) &#123;</span><br><span class="line">(gdb) p server.port</span><br><span class="line">$1 = 6379</span><br><span class="line">(gdb) ptype server</span><br><span class="line">type = struct redisServer &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pthread_t main_thread_id;</span><br><span class="line">    char *configfile;</span><br><span class="line">    char *executable;</span><br><span class="line">    char **exec_argv;</span><br><span class="line">    int dynamic_hz;</span><br><span class="line">    int config_hz;</span><br><span class="line">    mode_t umask;</span><br><span class="line">    ....&#125;</span><br><span class="line">(gdb) ptype server.port</span><br><span class="line">type = int</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="info-和-thread"><a href="#info-和-thread" class="headerlink" title="info 和 thread"></a>info 和 thread</h3><ul>
<li><p><code>info thread</code>查看<code>redis-server</code>启动后一共产生<code>5</code>个线程，<code>1</code>个主线程和<code>4</code>个工作线程。主线程阻塞在<code>epoll_wait()</code>处，其他工作线程阻塞在<code>pthread_cond_wait()</code>处。<code>*</code>表示的是当前<code>gdb</code>作用于哪个线程上，而不是<code>*</code>就代表指向主线程。<br>  <img src="/2021/09/15/GDB/gdb18.png" alt="gdb18"></p>
</li>
<li><p><code>bt</code>查看当前线程的调用堆栈，如下图所示：<br>  <img src="/2021/09/15/GDB/gdb19.png" alt="gdb19"><br>堆栈#4上显示的调用<code>main()</code>函数表示当前线程即主线程。</p>
</li>
</ul>
<ul>
<li><code>thread num</code>切换到其他线程<br>  <img src="/2021/09/15/GDB/gdb20.png" alt="gdb20"></li>
</ul>
<h3 id="next-和-step"><a href="#next-和-step" class="headerlink" title="next 和 step"></a>next 和 step</h3><ul>
<li><code>next</code>单步步过(step over)，遇到函数直接跳过不会进入函数内部。(回车键默认是将最近的一条命令执行)</li>
<li><code>step</code>单步步入(step into)，遇到函数进入函数内部。</li>
</ul>
<h3 id="until-和-jump"><a href="#until-和-jump" class="headerlink" title="until 和 jump"></a>until 和 jump</h3><ul>
<li><code>until</code>可以指定程序运行到某一行停下来。</li>
<li><code>jump</code>可以指定程序执行流跳转到指定位置执行，若跳转的地方没有断点则会继续执行，可以用于测试异常分支代码。</li>
</ul>
<h3 id="finish-和-return"><a href="#finish-和-return" class="headerlink" title="finish 和 return"></a>finish 和 return</h3><ul>
<li><code>finish</code>命令会执行函数到正常退出该函数。</li>
<li><code>return</code>命令是立即结束执行当前函数并返回，即使当前函数还有剩余的代码未执行完毕，也不会执行。</li>
</ul>
<h3 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h3><ul>
<li><code>disassemble</code>命令查看汇编代码，一般用于高级调试选哟查看某段代码的汇编指令，或调试没有调式信息的发版程序。<br>  <img src="/2021/09/15/GDB/gdb21.png" alt="gdb21"></li>
</ul>
<h3 id="set-args-和-show-args"><a href="#set-args-和-show-args" class="headerlink" title="set args 和 show args"></a>set args 和 show args</h3><ul>
<li><code>set args</code>用于传递命令行参数。做法：<code>gdb</code>附加程序，在<code>run</code>之前，使用<code>set args 参数内容</code>来传递命令行参数。</li>
<li><code>show args</code>用于查看命令行参数是否设置成功。<br>  <img src="/2021/09/15/GDB/gdb22.png" alt="gdb22"></li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>用于监视一个变量或者一段内存，当其值发生变化时，<code>gdb</code>会中断下来。被监视的变量或内存会产生一个<code>watch point</code>(观察点)。</p>
<ul>
<li><p>watch命令时通过添加硬件断点来实现监视数据变化，格式：<code>watch 变量名/内存地址</code>。</p>
<ul>
<li><p>整形变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i;</span><br><span class="line">watch i</span><br></pre></td></tr></table></figure></li>
<li><p>指针类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *p;</span><br><span class="line">watch p </span><br><span class="line">watch *p</span><br></pre></td></tr></table></figure></li>
<li><p>数组/内存区间（这里是对buf的128个数据监视，不是采用硬件中断，是用软中断实现）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char buf[10];</span><br><span class="line">watch buf</span><br></pre></td></tr></table></figure></li>
<li><p>程序例子，可见<code>watch</code>的变量<code>a</code>的值在发生变化时会中断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    while (a &lt;= 5)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a*2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/15/GDB/gdb23.png" alt="gdb23"></p>
</li>
</ul>
</li>
</ul>
<h3 id="多进程-线程调试"><a href="#多进程-线程调试" class="headerlink" title="多进程/线程调试"></a>多进程/线程调试</h3><ul>
<li><p>调试父子进程</p>
<ul>
<li><code>gdb</code>调试父进程，等子进程<code>fork</code>完成后，使用<code>gdb attach pid</code>进入子进程，需要重新开启一个窗口用于调试。</li>
<li><code>gdb</code>调试器提供选项<code>follow-fork</code>，可以使用<code>show follow-fork mode</code>查看当前值，也可以通过<code>set follow-fork mode</code>来设置是当一个进程<code>fork</code>出新的子进程时，<code>gdb</code>时继续调试父进程还是子进程（取值<code>child</code>），默认是父进程（取值<code>parent</code>）</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) show follow-fork mode     </span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;parent&quot;.</span><br><span class="line">(gdb) set follow-fork child</span><br><span class="line">(gdb) show follow-fork mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;child&quot;.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li>
<li><p>spp 线程</p>
<ul>
<li>在<code>tool</code>目录下将服务停止</li>
<li>进入<code>bin</code>目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./spp_xxx_proxy ../etc/spp_proxy.xml</span><br><span class="line">gdb --args ./spp_xxx_worker ../etc/spp_worker1.xml</span><br><span class="line">set follow-fork-mode child</span><br><span class="line">b 设置断点</span><br><span class="line">r 运行程序</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/12/hello/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法总结</title>
    <url>/2021/09/13/sort/</url>
    <content><![CDATA[<p>本文介绍的几种排序算法的时间复杂度、额外空间复杂度、稳定性如下：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>bubble</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
<tr>
<td>insert</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
<tr>
<td>select</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>no</td>
</tr>
<tr>
<td>merge</td>
<td>O(n*logn)</td>
<td>O(n)</td>
<td>yes</td>
</tr>
<tr>
<td>heap</td>
<td>O(n*logn)</td>
<td>O(1)</td>
<td>no</td>
</tr>
<tr>
<td>quick</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>no</td>
</tr>
</tbody></table>
<p>稳定性概念：保证集合中的元素在排序后的相对次序和排序前为一致则是稳定的。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始顺序：[a1, b1, a2, a3, c5]</span><br><span class="line">排序顺序：[a1, a2, a3, b1, c5]</span><br><span class="line">其中三个a类型的相对次序没有发生变化则表示是稳定的。</span><br></pre></td></tr></table></figure>

<h1 id="1-bubble-sort"><a href="#1-bubble-sort" class="headerlink" title="1. bubble sort"></a>1. bubble sort</h1><ul>
<li>原理：每一轮将该集合的元素中最大的一个沉底即可。</li>
<li>例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">  第<span class="number">1</span>轮：实现将最大的<span class="number">8</span>放到最后一个位置</span><br><span class="line">  [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>]</span><br><span class="line">  </span><br><span class="line">  第<span class="number">2</span>轮：实现将最大的<span class="number">7</span>放到倒数第<span class="number">2</span>个位置</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">  以此类推，若集合的大小是n，则需要进行n轮，每轮比较n次</span><br><span class="line">  则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-insert-sort"><a href="#2-insert-sort" class="headerlink" title="2. insert sort"></a>2. insert sort</h1><ul>
<li>原理：将<code>index = 0</code>的位置看作是一个有序区，之后将后续的元素按照大小插入到有序区对应的位置即可。</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    第<span class="number">1</span>轮：[<span class="number">7</span>]是有序区</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    第<span class="number">2</span>轮：[<span class="number">6</span>, <span class="number">7</span>]是有序区</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">3</span>轮：[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]是有序区</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    以此类推，若集合的大小是n，则需要进行n轮，</span><br><span class="line">    比较的次数是一个等差数列的和，则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-select-sort"><a href="#3-select-sort" class="headerlink" title="3. select sort"></a>3. select sort</h1></li>
<li>原理：从元素中找出最小的数放到集合的<code>index=0</code>的位置，之后轮询n次每次将最小的数放到有序集合后面即可。</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    第<span class="number">1</span>轮：选择最小的元素<span class="number">0</span>放到起始位置</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>] </span><br><span class="line">    </span><br><span class="line">    以此类推，若集合大小是n，则需要进行n轮，</span><br><span class="line">    比较的次数是一个等差数列的和，则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-merge-sort"><a href="#4-merge-sort" class="headerlink" title="4. merge sort"></a>4. merge sort</h1></li>
<li>原理：不停的将集合二分（逻辑上的划分），直到元素不能再划分为止，则申请对应的空间按相对大小填充返回即可。</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">    第<span class="number">1</span>轮：以 index = <span class="number">2</span> 开始划分</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]  [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">2</span>轮：将第<span class="number">1</span>轮的集合左右各自继续划分</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>] [<span class="number">4</span>] [<span class="number">5</span>, <span class="number">3</span>] [<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">3</span>轮：将第<span class="number">2</span>轮中可以划分的继续划分</span><br><span class="line">    [<span class="number">2</span>] [<span class="number">1</span>] [<span class="number">4</span>] [<span class="number">5</span>] [<span class="number">3</span>] [<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">4</span>轮：按照划分好的结果通过大小逆序向上合并填充即可</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>] [<span class="number">4</span>] [<span class="number">3</span>, <span class="number">5</span>] [<span class="number">6</span>] -&gt;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>] -&gt; </span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(a, l, mid, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> help[len];</span><br><span class="line">    <span class="keyword">int</span> help_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">        help[help_idx++] = a[p1] &lt; a[p2] ? a[p1++] : a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">         help[help_idx++] = a[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)&#123;</span><br><span class="line">         help[help_idx++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        a[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>应用：<ul>
<li>小和问题：每个位置上左边有比该位置值小的所有的数的和。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2, 1, 4, 5, 3, 6]</span><br><span class="line">small_sum = (2 + 1) + </span><br><span class="line">            (2 + 1 + 4) + </span><br><span class="line">            (2 + 1) + </span><br><span class="line">            (1 + 2 + 3 + 4 + 5)</span><br><span class="line">在 merge 的过程中就可以计算出所有小和</span><br><span class="line">a[i] &lt; a[j] 则出现的次数总和为：(r - j + 1) * a[i]</span><br></pre></td></tr></table></figure></li>
<li>逆序对：每个位置右边有比该位置数小的数对个数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2, 1, 4, 5, 3, 6]</span><br><span class="line">逆序对个数：</span><br><span class="line">[2, 1]</span><br><span class="line">[4, 3]</span><br><span class="line">[5, 3]</span><br><span class="line">在 merge 的过程中可以求取逆序对个数：</span><br><span class="line">a[i] &gt; a[j] 则逆序对的个数为：(mid - i + 1)</span><br></pre></td></tr></table></figure>
<h1 id="5-heap-sort"><a href="#5-heap-sort" class="headerlink" title="5. heap sort"></a>5. heap sort</h1></li>
</ul>
</li>
<li>原理：堆排的实现对应算法中的优先级队列，核心分为2步：<strong>建堆</strong>和<strong>调堆</strong><ul>
<li><p><strong>建堆</strong>：通过比较当前位置的树是否比起父节点大的方法来创建一个大根堆（以该节点为根的树是该节点是最大值）。建堆只需要在数组上调整即可，逻辑上对应的是一棵完全二叉树，时间复杂度为<code>O(n)</code>。<br>关注两点：</p>
<blockquote>
<p>父节点<code>index = i</code>，左右孩子节点<code>left = 2*i + 1, right = 2*i + 2</code>；<br>孩子节点<code>index = i</code>，父节点<code>fa = (i - 1) / 2</code></p>
</blockquote>
</li>
<li><p><strong>调堆</strong>：将堆的根节点调到最后一个叶子节点处（即数组的最后一个位置），剪枝，之后从根节点进行元素调整继续维护为一个大根堆的样子便于下次取到最大值元素，该操作的时间复杂度为<code>O(n*logn)</code></p>
</li>
</ul>
</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">step1: 建堆，判断当前位置的数是否比其父亲节点大，若大则交换，则index从<span class="number">0</span>到N扫描，第i个节点树的高度为<span class="built_in">log</span>(i)</span><br><span class="line">则<span class="built_in">T</span>(N) = <span class="built_in">log</span>(<span class="number">1</span>) + <span class="built_in">log</span>(<span class="number">2</span>) + ... + <span class="built_in">log</span>(N) 可以在<span class="built_in">O</span>(N)内收敛</span><br><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">step2: 调堆 <span class="built_in">O</span>(N * logN)</span><br><span class="line">将<span class="number">7</span>置换到数组末尾进行剪枝后再进行调堆</span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] -&gt;</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, (<span class="number">7</span>)] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, (<span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line">以此类推直到取完最后一个节点为止即可</span><br></pre></td></tr></table></figure></li>
<li>例子示例图：<ul>
<li>建堆图：<!-- ![](./sort/建堆过程.png)  该形式是在预览时使用 -->
<!-- ![](建堆过程.png)  该形式是在部署时使用-->
<img src="/2021/09/13/sort/%E5%BB%BA%E5%A0%86%E8%BF%87%E7%A8%8B.png"> </li>
<li>剪枝调堆图：<br><img src="/2021/09/13/sort/%E5%89%AA%E6%9E%9D%E8%B0%83%E5%A0%86.png"></li>
</ul>
</li>
<li>实现：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="built_in">heapInsert</span>(a, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = len;</span><br><span class="line">    <span class="built_in">swap</span>(a[<span class="number">0</span>], a[--size]);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">0</span>], a[--size]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a[index] &gt; a[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[index], a[(index - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; a[left + <span class="number">1</span>] &gt; a[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = a[largest] &gt; a[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[largest], a[index]);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-quick-sort"><a href="#6-quick-sort" class="headerlink" title="6. quick sort"></a>6. quick sort</h1></li>
<li>原理：核心<code>partition</code>过程来将数组按照随机选定一个值<code>p</code>将元素划分为<code>&lt;p, =p, &gt;p</code>三个区域，将等于区域返回之后继续递归划分直到不能划分结束。<ul>
<li>随机选定元素的原因：从规模上减少每次选择的划分值不好，增大递归的规模，从而使时间复杂度退化为<code>O(n^2)</code>。</li>
<li>递归划分时每次都选择中间值，则递归规模每次为<code>n/2</code>，根据<code>master</code>公式可以得知<code>T(N) = 2 * T(N / 2) + O(N^1)</code>，则时间复杂度收敛到<code>O(N*logN)</code>。</li>
</ul>
</li>
<li>例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">  step1: 假设随机选取划分值p = <span class="number">4</span></span><br><span class="line">  step2: partition过程，根据p = <span class="number">4</span>进行划分，该过程时间复杂度<span class="built_in">O</span>(N)</span><br><span class="line">      a[i] &lt; p 时则小于区域扩大，小于区的下一个元素和a[i]交换，同时i自增</span><br><span class="line">      a[i] = p 时则等于区扩大，i自增</span><br><span class="line">      a[i] &gt; p 时则i保持不变，大于区前一个数和a[i]交换，大于区扩大</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">  step3：将partition过程等于区域的index数组[<span class="number">3</span>, <span class="number">3</span>]返回用于下一次递归即可</span><br><span class="line"></span><br><span class="line">  额外空间复杂度 <span class="built_in">O</span>(N*logN)，用于保存partition过程中树的节点</span><br></pre></td></tr></table></figure></li>
<li>实现：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> r_index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[r_index], a[r]);</span><br><span class="line">        <span class="keyword">int</span> *parr = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">        <span class="built_in">quickSort</span>(a, l, parr[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(a, parr[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> *parr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> m = l;</span><br><span class="line">    <span class="keyword">while</span> (m &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[m] &lt; a[r])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[++less], a[m++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[m] == a[r])&#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[m], a[--more]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[r], a[more]);</span><br><span class="line">    parr[<span class="number">0</span>] = less + <span class="number">1</span>;</span><br><span class="line">    parr[<span class="number">1</span>] = more;</span><br><span class="line">    <span class="keyword">return</span> parr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>master公式普及<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(N) = a * <span class="built_in">T</span>(N / b) + <span class="built_in">O</span>(N^d)</span><br><span class="line">(<span class="number">1</span>) <span class="built_in">logb</span>(a) = d 则 <span class="built_in">T</span>(N) = N^d * <span class="built_in">logN</span></span><br><span class="line">(<span class="number">2</span>) <span class="built_in">logb</span>(a) &gt; d 则 <span class="built_in">T</span>(N) = N^<span class="built_in">logb</span>(a)</span><br><span class="line">(<span class="number">3</span>) <span class="built_in">logb</span>(a) &lt; d 则 <span class="built_in">T</span>(N) = N^d</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找学习总结</title>
    <url>/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文总结二分查找算法，其实该算法的思想是很简单的。即在有序的线性存储结构中进行查找。</p>
<blockquote>
<ol>
<li>选择<code>mid</code>位置的元素<code>x</code>是否等于<code>target</code>，相等则终止查找；</li>
<li>若<code>x &lt; target</code>则需要向右半区间查找，更新<strong>左</strong>边界；</li>
<li>若<code>x &gt; target</code>则需要向左半区间查找，更新<strong>右</strong>边界;</li>
<li>重复前面几步直到不能再划分为止。</li>
</ol>
</blockquote>
<h1 id="1-关键点：查询的边界确定问题"><a href="#1-关键点：查询的边界确定问题" class="headerlink" title="1. 关键点：查询的边界确定问题"></a>1. 关键点：查询的边界确定问题</h1><p><strong>循环不变量的确定</strong>：即每次查询的左右区间维持一致，确保查询不重不漏</p>
<h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><ul>
<li>左闭右闭写法 <strong>[left, right]</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;    <span class="comment">// key：决定了[l, r]查找</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123; <span class="comment">// 需要更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123; <span class="comment">// 需要更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>左闭右开写法 <strong>[left, right)</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;    <span class="comment">// key：决定了[l, r)查找</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找应用1</title>
    <url>/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A81/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<ul>
<li>要求：时间复杂度为 O(log n)   </li>
<li>例子：<ul>
<li>输入: nums = [1,3,5,6], target = 5    输出: 2</li>
<li>输入: nums = [1,3,5,6], target = 2    输出: 1</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/">leetcode链接</a><h1 id="解法：改写二分"><a href="#解法：改写二分" class="headerlink" title="解法：改写二分"></a>解法：改写二分</h1></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123; <span class="comment">// 用于判断左边界 比如[1,3,5,6] target=0</span></span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找应用2</title>
    <url>/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A82/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<ul>
<li>要求：时间复杂度为 O(log n)   </li>
<li>例子：<ul>
<li>输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]</li>
<li>输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1]</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode链接</a></li>
</ul>
<h1 id="解法：改写二分"><a href="#解法：改写二分" class="headerlink" title="解法：改写二分"></a>解法：改写二分</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindLeft</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">FindLeft</span>(nums, target);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">FindRight</span>(nums, target);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-BinarySearch</tag>
      </tags>
  </entry>
</search>
