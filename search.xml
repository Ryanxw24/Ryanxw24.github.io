<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GDB调试学习总结</title>
    <url>/2021/09/15/GDB/</url>
    <content><![CDATA[<h1 id="GDB调试学习总结"><a href="#GDB调试学习总结" class="headerlink" title="GDB调试学习总结"></a>GDB调试学习总结</h1><h2 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h2><table>
<thead>
<tr>
<th>命令名称</th>
<th>命令缩写</th>
<th>命令说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td>r</td>
<td>运行一个程序</td>
<td></td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>添加断点</td>
<td>-b xx.cpp:line</td>
</tr>
<tr>
<td>delete</td>
<td>del</td>
<td>删除断点</td>
<td></td>
</tr>
<tr>
<td>list</td>
<td>l</td>
<td>显示源代码</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>让暂停的程序继续运行</td>
<td></td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>运行到下一行源代码，不进入函数内部</td>
<td></td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>运行到下一行源代码，进入函数内部</td>
<td></td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印变量或者寄存器的值</td>
<td></td>
</tr>
<tr>
<td>until</td>
<td>u</td>
<td>运行到指定行停止下来</td>
<td></td>
</tr>
<tr>
<td>jump</td>
<td>j</td>
<td>将当前程序执行流跳转到指定行或地址</td>
<td></td>
</tr>
<tr>
<td>backtrace</td>
<td>bt</td>
<td>查看当前线程的调用堆栈</td>
<td></td>
</tr>
<tr>
<td>thread</td>
<td>thread</td>
<td>切换到指定线程</td>
<td></td>
</tr>
<tr>
<td>frame</td>
<td>f</td>
<td>切换到当前调用线程的指定堆栈,具体堆栈通过堆栈序号指定</td>
<td></td>
</tr>
<tr>
<td>info</td>
<td>info</td>
<td>查看断点/线程等信息</td>
<td></td>
</tr>
<tr>
<td>ptype</td>
<td>ptype</td>
<td>查看变量类型</td>
<td></td>
</tr>
<tr>
<td>disassemble</td>
<td>dis</td>
<td>查看汇编代码</td>
<td></td>
</tr>
<tr>
<td>watch</td>
<td>watch</td>
<td>监视某一个变量或内存地址的值是否发生变化</td>
<td></td>
</tr>
<tr>
<td>finish</td>
<td>fin</td>
<td>结束当前调用函数，返回到上一层函数调用处</td>
<td></td>
</tr>
<tr>
<td>return</td>
<td>return</td>
<td>结束当前调用函数并返回指定值，到上一层函数调用处</td>
<td></td>
</tr>
</tbody></table>
<h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><h3 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h3><ul>
<li><code>gdb filename</code><br>开发过程中，编译生成目标二进制文件后，可以直接<code>gdb filename</code>开始调试，输入<code>run</code>或<code>r</code>运行程序。比如下图所示：<br>  <img src="/2021/09/15/GDB/gdb1.png" alt="gdb1"><br>启动后可以通过<code>netstat -nltp | grep 6379</code>来查看程序已经运行起来了<br>  <img src="/2021/09/15/GDB/gdb2.png" alt="gdb2"></li>
</ul>
<h3 id="附加进程调试"><a href="#附加进程调试" class="headerlink" title="附加进程调试"></a>附加进程调试</h3><ul>
<li><code>gdb attach pid</code><br>如果当程序已经启动后想调试，但是不想重启程序。或者当程序在测试过程中，不能重启，一旦重启则会丢失当前的状态信息。这种情况下就使用附加进程进行调试。<ul>
<li>获取进程pid<br><img src="/2021/09/15/GDB/gdb3.png" alt="gdb3"></li>
<li>生成附加进程<br><img src="/2021/09/15/GDB/gdb4.png" alt="gdb4"><br>提示 “Attaching to process 8380 时即已成功将 GDB 附加到目标进程，结束调试后输入<code>detach</code>离开且不对当前进程有影响，让程序和gdb调试器分离，如下图：<br><img src="/2021/09/15/GDB/gdb5.png" alt="gdb5"></li>
</ul>
</li>
</ul>
<h3 id="core文件调试"><a href="#core文件调试" class="headerlink" title="core文件调试"></a>core文件调试</h3><p>coredump即核心转储，是进程运行崩溃瞬间的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存到core文件，该文件是个二进制文件，可以使用gdb进行分析。</p>
<ul>
<li><p>产生原因</p>
<ul>
<li>内存访问越界</li>
<li>多线程程序使用了线程不安全的函数</li>
<li>多线程读写数据未加锁保护，对于被多个线程同时访问的全局数据，要加锁保护否则会coredump</li>
<li>非法指针</li>
<li>堆栈溢出</li>
</ul>
</li>
<li><p>查看系统产生core文件后存放的位置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xw@null coredump]$ cat /proc/sys/kernel/core_pattern </span><br><span class="line">/data/coredump/core_%e_%t</span><br><span class="line">- 表示产生的core文件都以core_%e_%t格式保存到/data/coredump/目录下</span><br><span class="line">-e 程序文件名</span><br><span class="line">-t 时间戳</span><br><span class="line">-p 进程ID</span><br><span class="line">-s 使进程崩溃的信号signal</span><br></pre></td></tr></table></figure></li>
<li><p>修改core文件的存储位置</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;/data/coredump/core_%e_%t&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></li>
<li><p>修改core文件大小<br>  (1) ulimit -c 查看参数core file size的值，如果为0表示不会生成core文件，一般修改为unlimited</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xw@null ~]$ ulimit -c</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>  (2) 修改core文件大小</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xw@null ~]$ ulimit -c unlimited</span><br><span class="line">[xw@null ~]$ ulimit -c</span><br><span class="line">unlimited</span><br></pre></td></tr></table></figure></li>
<li><p><code>readelf -h corefile</code>查看core文件头<br>  <img src="/2021/09/15/GDB/core8.png" alt="core8"></p>
</li>
<li><p>gdb调试core文件</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb 执行文件 core文件</span><br><span class="line">where/bt 查看堆栈信息进一步分析程序</span><br></pre></td></tr></table></figure></li>
<li><p>参考链接</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/98700797">linux coredump调试</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46605905">gdb调试coredump</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/199841770">linux上创建并调试转储文件</a></li>
</ul>
</li>
</ul>
<h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxxx@gzqc-172_24_21_96-null src]$ gdb redis-server</span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/15/GDB/gdb6.png" alt="gdb6"><br>此时只是附加了一个调试文件，程序还未启动，输入<code>run</code>命令即可运行程序。<br><img src="/2021/09/15/GDB/gdb7.png" alt="gdb7"><br>按<code>Ctrl+C</code>可以中断<code>gdb</code>,再次输入<code>r</code>后输入<code>y</code>重启程序<br><img src="/2021/09/15/GDB/gdb8.png" alt="gdb8"></p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>按<code>Ctrl+C</code>可以中断<code>gdb</code>,输入<code>c</code>可以使程序继续运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff71e9d43 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul>
<li><p><code>break</code>用于添加断点，添加完成后重启程序即可触发，停在断点处</p>
<ul>
<li><code>break func</code>在函数名入口处添加断点 </li>
<li><code>break line</code>在当前文件行号line处添加断点</li>
<li><code>break filename:line</code>在文件filename行号line处添加断点<br><img src="/2021/09/15/GDB/gdb9.png" alt="gdb9"></li>
</ul>
</li>
<li><p>redis-server端口<code>6379</code>，端口号肯定是通过<code>bind()</code>函数创建的，搜索文件位于<code>anet.c 401 </code>行。<br>  <img src="/2021/09/15/GDB/gdb10.png" alt="gdb10"></p>
<ul>
<li>在<code>anet.c:401</code>处添加断点后重启触发断点<code>1</code>, <code>continue</code>后触发断点<code>2</code>。如下所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b anet.c:401</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /data/home/xxxx/redis-6.2.3/src/redis-server </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.</span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdf58) at server.c:6151</span><br><span class="line">6151        char config_from_stdin = 0;</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 2, anetListen (err=0xbcee50 &lt;server+752&gt; &quot;&quot;, s=10, sa=0xdf79a0, len=16, backlog=511) at anet.c:401</span><br><span class="line">401         if (bind(s,sa,len) == -1) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>分别在<code>anet.c 404 410 412</code>处添加断点，用于判断从该函数从何处返回。如下图所示：<br><img src="/2021/09/15/GDB/gdb12.png" alt="gdb12"></li>
<li><code>continue</code>可以看到触发断点<code>5</code>。如下图所示：<br><img src="/2021/09/15/GDB/gdb13.png" alt="gdb13"></li>
</ul>
</li>
</ul>
<h3 id="backtrace-和-frame"><a href="#backtrace-和-frame" class="headerlink" title="backtrace 和 frame"></a>backtrace 和 frame</h3><ul>
<li><p><code>backtrace</code>用于查看堆栈信息。<code>frame</code>用于切换到某个堆栈处。上面的gdb程序中断在<code>anet.c:412</code>处</p>
<ul>
<li><p><code>bt</code>查看此时的堆栈信息共有6层堆栈<code>#0 ~ #5</code>，如下图所示：<br><img src="/2021/09/15/GDB/gdb15.png" alt="gdb15"></p>
</li>
<li><p><code>frame 堆栈编号</code>切换堆栈信息，如下图所示：<br><img src="/2021/09/15/GDB/gdb14.png" alt="gdb14"><br>  可以得到调用关系</p>
<ul>
<li><code>main()</code>函数在6322行调用<code>initServer()</code>函数</li>
<li><code>initServer()</code>函数在3195行调用<code>listenToPort()</code>函数</li>
<li><code>listenToPort()</code>函数在3052行调用<code>anetTcpServer()</code>函数</li>
<li><code>anetTcpServer()</code>函数在468行调用<code>_anetTcpServer()</code>函数</li>
<li><code>_anetTcpServer()</code>函数在450行调用<code>anetListen()</code>函数</li>
<li>此时断点正停在<code>anetListen()</code>函数中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="info-break、enable、disable、delete"><a href="#info-break、enable、disable、delete" class="headerlink" title="info break、enable、disable、delete"></a>info break、enable、disable、delete</h3><ul>
<li><code>info b</code>查看断点个数<br>  <img src="/2021/09/15/GDB/gdb16.png" alt="gdb16"></li>
<li><code>enable num</code>启用编号为num的断点，不加参数表示全部启用</li>
<li><code>disable num</code>禁用编号为num的断点，不加参数表示全部禁用</li>
<li><code>delete num</code>删除编号为num的断点，不加参数表示全部删除  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">3       breakpoint     keep y   0x000000000043412c in anetListen at anet.c:404</span><br><span class="line">4       breakpoint     keep y   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) disable 4</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">3       breakpoint     keep y   0x000000000043412c in anetListen at anet.c:404</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) delete 3</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) disable </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep n   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep n   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) enable </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep y   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) delete </span><br><span class="line">Delete all breakpoints? (y or n) y       </span><br><span class="line">(gdb) info b</span><br><span class="line">No breakpoints or watchpoints.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul>
<li><code>list</code>用于显示源码，默认显示10行。如图所示：<br>  <img src="/2021/09/15/GDB/gdb17.png" alt="gdb17"></li>
</ul>
<h3 id="print、ptype"><a href="#print、ptype" class="headerlink" title="print、ptype"></a>print、ptype</h3><ul>
<li><code>print</code>用于查看变量的值，<code>ptype</code>用于查看变量类型。如下所示：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) f 4</span><br><span class="line">#4  0x000000000043b304 in initServer () at server.c:3195</span><br><span class="line">3195            listenToPort(server.port,&amp;server.ipfd) == C_ERR) &#123;</span><br><span class="line">(gdb) p server.port</span><br><span class="line">$1 = 6379</span><br><span class="line">(gdb) ptype server</span><br><span class="line">type = struct redisServer &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pthread_t main_thread_id;</span><br><span class="line">    char *configfile;</span><br><span class="line">    char *executable;</span><br><span class="line">    char **exec_argv;</span><br><span class="line">    int dynamic_hz;</span><br><span class="line">    int config_hz;</span><br><span class="line">    mode_t umask;</span><br><span class="line">    ....&#125;</span><br><span class="line">(gdb) ptype server.port</span><br><span class="line">type = int</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="info-和-thread"><a href="#info-和-thread" class="headerlink" title="info 和 thread"></a>info 和 thread</h3><ul>
<li><p><code>info thread</code>查看<code>redis-server</code>启动后一共产生<code>5</code>个线程，<code>1</code>个主线程和<code>4</code>个工作线程。主线程阻塞在<code>epoll_wait()</code>处，其他工作线程阻塞在<code>pthread_cond_wait()</code>处。<code>*</code>表示的是当前<code>gdb</code>作用于哪个线程上，而不是<code>*</code>就代表指向主线程。<br>  <img src="/2021/09/15/GDB/gdb18.png" alt="gdb18"></p>
</li>
<li><p><code>bt</code>查看当前线程的调用堆栈，如下图所示：<br>  <img src="/2021/09/15/GDB/gdb19.png" alt="gdb19"><br>堆栈#4上显示的调用<code>main()</code>函数表示当前线程即主线程。</p>
</li>
</ul>
<ul>
<li><code>thread num</code>切换到其他线程<br>  <img src="/2021/09/15/GDB/gdb20.png" alt="gdb20"></li>
</ul>
<h3 id="next-和-step"><a href="#next-和-step" class="headerlink" title="next 和 step"></a>next 和 step</h3><ul>
<li><code>next</code>单步步过(step over)，遇到函数直接跳过不会进入函数内部。(回车键默认是将最近的一条命令执行)</li>
<li><code>step</code>单步步入(step into)，遇到函数进入函数内部。</li>
</ul>
<h3 id="until-和-jump"><a href="#until-和-jump" class="headerlink" title="until 和 jump"></a>until 和 jump</h3><ul>
<li><code>until</code>可以指定程序运行到某一行停下来。</li>
<li><code>jump</code>可以指定程序执行流跳转到指定位置执行，若跳转的地方没有断点则会继续执行，可以用于测试异常分支代码。</li>
</ul>
<h3 id="finish-和-return"><a href="#finish-和-return" class="headerlink" title="finish 和 return"></a>finish 和 return</h3><ul>
<li><code>finish</code>命令会执行函数到正常退出该函数。</li>
<li><code>return</code>命令是立即结束执行当前函数并返回，即使当前函数还有剩余的代码未执行完毕，也不会执行。</li>
</ul>
<h3 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h3><ul>
<li><code>disassemble</code>命令查看汇编代码，一般用于高级调试选哟查看某段代码的汇编指令，或调试没有调式信息的发版程序。<br>  <img src="/2021/09/15/GDB/gdb21.png" alt="gdb21"></li>
</ul>
<h3 id="set-args-和-show-args"><a href="#set-args-和-show-args" class="headerlink" title="set args 和 show args"></a>set args 和 show args</h3><ul>
<li><code>set args</code>用于传递命令行参数。做法：<code>gdb</code>附加程序，在<code>run</code>之前，使用<code>set args 参数内容</code>来传递命令行参数。</li>
<li><code>show args</code>用于查看命令行参数是否设置成功。<br>  <img src="/2021/09/15/GDB/gdb22.png" alt="gdb22"></li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>用于监视一个变量或者一段内存，当其值发生变化时，<code>gdb</code>会中断下来。被监视的变量或内存会产生一个<code>watch point</code>(观察点)。</p>
<ul>
<li><p>watch命令时通过添加硬件断点来实现监视数据变化，格式：<code>watch 变量名/内存地址</code>。</p>
<ul>
<li><p>整形变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i;</span><br><span class="line">watch i</span><br></pre></td></tr></table></figure></li>
<li><p>指针类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *p;</span><br><span class="line">watch p </span><br><span class="line">watch *p</span><br></pre></td></tr></table></figure></li>
<li><p>数组/内存区间（这里是对buf的128个数据监视，不是采用硬件中断，是用软中断实现）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char buf[10];</span><br><span class="line">watch buf</span><br></pre></td></tr></table></figure></li>
<li><p>程序例子，可见<code>watch</code>的变量<code>a</code>的值在发生变化时会中断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    while (a &lt;= 5)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a*2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/15/GDB/gdb23.png" alt="gdb23"></p>
</li>
</ul>
</li>
</ul>
<h3 id="多进程-线程调试"><a href="#多进程-线程调试" class="headerlink" title="多进程/线程调试"></a>多进程/线程调试</h3><ul>
<li><p>调试父子进程</p>
<ul>
<li><code>gdb</code>调试父进程，等子进程<code>fork</code>完成后，使用<code>gdb attach pid</code>进入子进程，需要重新开启一个窗口用于调试。</li>
<li><code>gdb</code>调试器提供选项<code>follow-fork</code>，可以使用<code>show follow-fork mode</code>查看当前值，也可以通过<code>set follow-fork mode</code>来设置是当一个进程<code>fork</code>出新的子进程时，<code>gdb</code>时继续调试父进程还是子进程（取值<code>child</code>），默认是父进程（取值<code>parent</code>）</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) show follow-fork mode     </span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;parent&quot;.</span><br><span class="line">(gdb) set follow-fork child</span><br><span class="line">(gdb) show follow-fork mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;child&quot;.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li>
<li><p>spp 线程</p>
<ul>
<li>在<code>tool</code>目录下将服务停止</li>
<li>进入<code>bin</code>目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./spp_xxx_proxy ../etc/spp_proxy.xml</span><br><span class="line">gdb --args ./spp_xxx_worker ../etc/spp_worker1.xml</span><br><span class="line">set follow-fork-mode child</span><br><span class="line">b 设置断点</span><br><span class="line">r 运行程序</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/12/hello/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法总结</title>
    <url>/2021/09/13/sort/</url>
    <content><![CDATA[<p>本文介绍的几种排序算法的时间复杂度、额外空间复杂度、稳定性如下：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>bubble</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
<tr>
<td>insert</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>yes</td>
</tr>
<tr>
<td>select</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>no</td>
</tr>
<tr>
<td>merge</td>
<td>O(n*logn)</td>
<td>O(n)</td>
<td>yes</td>
</tr>
<tr>
<td>heap</td>
<td>O(n*logn)</td>
<td>O(1)</td>
<td>no</td>
</tr>
<tr>
<td>quick</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>no</td>
</tr>
</tbody></table>
<p>稳定性概念：保证集合中的元素在排序后的相对次序和排序前为一致则是稳定的。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始顺序：[a1, b1, a2, a3, c5]</span><br><span class="line">排序顺序：[a1, a2, a3, b1, c5]</span><br><span class="line">其中三个a类型的相对次序没有发生变化则表示是稳定的。</span><br></pre></td></tr></table></figure>

<h1 id="1-bubble-sort"><a href="#1-bubble-sort" class="headerlink" title="1. bubble sort"></a>1. bubble sort</h1><ul>
<li>原理：每一轮将该集合的元素中最大的一个沉底即可。</li>
<li>例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">  第<span class="number">1</span>轮：实现将最大的<span class="number">8</span>放到最后一个位置</span><br><span class="line">  [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>]</span><br><span class="line">  </span><br><span class="line">  第<span class="number">2</span>轮：实现将最大的<span class="number">7</span>放到倒数第<span class="number">2</span>个位置</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">  以此类推，若集合的大小是n，则需要进行n轮，每轮比较n次</span><br><span class="line">  则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-insert-sort"><a href="#2-insert-sort" class="headerlink" title="2. insert sort"></a>2. insert sort</h1><ul>
<li>原理：将<code>index = 0</code>的位置看作是一个有序区，之后将后续的元素按照大小插入到有序区对应的位置即可。</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    第<span class="number">1</span>轮：[<span class="number">7</span>]是有序区</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    第<span class="number">2</span>轮：[<span class="number">6</span>, <span class="number">7</span>]是有序区</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">3</span>轮：[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]是有序区</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    以此类推，若集合的大小是n，则需要进行n轮，</span><br><span class="line">    比较的次数是一个等差数列的和，则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-select-sort"><a href="#3-select-sort" class="headerlink" title="3. select sort"></a>3. select sort</h1></li>
<li>原理：从元素中找出最小的数放到集合的<code>index=0</code>的位置，之后轮询n次每次将最小的数放到有序集合后面即可。</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    第<span class="number">1</span>轮：选择最小的元素<span class="number">0</span>放到起始位置</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>] </span><br><span class="line">    </span><br><span class="line">    以此类推，若集合大小是n，则需要进行n轮，</span><br><span class="line">    比较的次数是一个等差数列的和，则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-merge-sort"><a href="#4-merge-sort" class="headerlink" title="4. merge sort"></a>4. merge sort</h1></li>
<li>原理：不停的将集合二分（逻辑上的划分），直到元素不能再划分为止，则申请对应的空间按相对大小填充返回即可。</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">    第<span class="number">1</span>轮：以 index = <span class="number">2</span> 开始划分</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]  [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">2</span>轮：将第<span class="number">1</span>轮的集合左右各自继续划分</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>] [<span class="number">4</span>] [<span class="number">5</span>, <span class="number">3</span>] [<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">3</span>轮：将第<span class="number">2</span>轮中可以划分的继续划分</span><br><span class="line">    [<span class="number">2</span>] [<span class="number">1</span>] [<span class="number">4</span>] [<span class="number">5</span>] [<span class="number">3</span>] [<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">4</span>轮：按照划分好的结果通过大小逆序向上合并填充即可</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>] [<span class="number">4</span>] [<span class="number">3</span>, <span class="number">5</span>] [<span class="number">6</span>] -&gt;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>] -&gt; </span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li>
<li>实现：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(a, l, mid, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> help[len];</span><br><span class="line">    <span class="keyword">int</span> help_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">        help[help_idx++] = a[p1] &lt; a[p2] ? a[p1++] : a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">         help[help_idx++] = a[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)&#123;</span><br><span class="line">         help[help_idx++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        a[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>应用：<ul>
<li>小和问题：每个位置上左边有比该位置值小的所有的数的和。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2, 1, 4, 5, 3, 6]</span><br><span class="line">small_sum = (2 + 1) + </span><br><span class="line">            (2 + 1 + 4) + </span><br><span class="line">            (2 + 1) + </span><br><span class="line">            (1 + 2 + 3 + 4 + 5)</span><br><span class="line">在 merge 的过程中就可以计算出所有小和</span><br><span class="line">a[i] &lt; a[j] 则出现的次数总和为：(r - j + 1) * a[i]</span><br></pre></td></tr></table></figure></li>
<li>逆序对：每个位置右边有比该位置数小的数对个数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2, 1, 4, 5, 3, 6]</span><br><span class="line">逆序对个数：</span><br><span class="line">[2, 1]</span><br><span class="line">[4, 3]</span><br><span class="line">[5, 3]</span><br><span class="line">在 merge 的过程中可以求取逆序对个数：</span><br><span class="line">a[i] &gt; a[j] 则逆序对的个数为：(mid - i + 1)</span><br></pre></td></tr></table></figure>
<h1 id="5-heap-sort"><a href="#5-heap-sort" class="headerlink" title="5. heap sort"></a>5. heap sort</h1></li>
</ul>
</li>
<li>原理：堆排的实现对应算法中的优先级队列，核心分为2步：<strong>建堆</strong>和<strong>调堆</strong><ul>
<li><p><strong>建堆</strong>：通过比较当前位置的树是否比起父节点大的方法来创建一个大根堆（以该节点为根的树是该节点是最大值）。建堆只需要在数组上调整即可，逻辑上对应的是一棵完全二叉树，时间复杂度为<code>O(n)</code>。<br>关注两点：</p>
<blockquote>
<p>父节点<code>index = i</code>，左右孩子节点<code>left = 2*i + 1, right = 2*i + 2</code>；<br>孩子节点<code>index = i</code>，父节点<code>fa = (i - 1) / 2</code></p>
</blockquote>
</li>
<li><p><strong>调堆</strong>：将堆的根节点调到最后一个叶子节点处（即数组的最后一个位置），剪枝，之后从根节点进行元素调整继续维护为一个大根堆的样子便于下次取到最大值元素，该操作的时间复杂度为<code>O(n*logn)</code></p>
</li>
</ul>
</li>
<li>例子：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">step1: 建堆，判断当前位置的数是否比其父亲节点大，若大则交换，则index从<span class="number">0</span>到N扫描，第i个节点树的高度为<span class="built_in">log</span>(i)</span><br><span class="line">则<span class="built_in">T</span>(N) = <span class="built_in">log</span>(<span class="number">1</span>) + <span class="built_in">log</span>(<span class="number">2</span>) + ... + <span class="built_in">log</span>(N) 可以在<span class="built_in">O</span>(N)内收敛</span><br><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">step2: 调堆 <span class="built_in">O</span>(N * logN)</span><br><span class="line">将<span class="number">7</span>置换到数组末尾进行剪枝后再进行调堆</span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] -&gt;</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, (<span class="number">7</span>)] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, (<span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line">以此类推直到取完最后一个节点为止即可</span><br></pre></td></tr></table></figure></li>
<li>例子示例图：<ul>
<li>建堆图：<!-- ![](./sort/建堆过程.png)  该形式是在预览时使用 -->
<!-- ![](建堆过程.png)  该形式是在部署时使用-->
<img src="/2021/09/13/sort/%E5%BB%BA%E5%A0%86%E8%BF%87%E7%A8%8B.png"> </li>
<li>剪枝调堆图：<br><img src="/2021/09/13/sort/%E5%89%AA%E6%9E%9D%E8%B0%83%E5%A0%86.png"></li>
</ul>
</li>
<li>实现：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="built_in">heapInsert</span>(a, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = len;</span><br><span class="line">    <span class="built_in">swap</span>(a[<span class="number">0</span>], a[--size]);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">0</span>], a[--size]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a[index] &gt; a[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[index], a[(index - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; a[left + <span class="number">1</span>] &gt; a[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = a[largest] &gt; a[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[largest], a[index]);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-quick-sort"><a href="#6-quick-sort" class="headerlink" title="6. quick sort"></a>6. quick sort</h1></li>
<li>原理：核心<code>partition</code>过程来将数组按照随机选定一个值<code>p</code>将元素划分为<code>&lt;p, =p, &gt;p</code>三个区域，将等于区域返回之后继续递归划分直到不能划分结束。<ul>
<li>随机选定元素的原因：从规模上减少每次选择的划分值不好，增大递归的规模，从而使时间复杂度退化为<code>O(n^2)</code>。</li>
<li>递归划分时每次都选择中间值，则递归规模每次为<code>n/2</code>，根据<code>master</code>公式可以得知<code>T(N) = 2 * T(N / 2) + O(N^1)</code>，则时间复杂度收敛到<code>O(N*logN)</code>。</li>
</ul>
</li>
<li>例子：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">  step1: 假设随机选取划分值p = <span class="number">4</span></span><br><span class="line">  step2: partition过程，根据p = <span class="number">4</span>进行划分，该过程时间复杂度<span class="built_in">O</span>(N)</span><br><span class="line">      a[i] &lt; p 时则小于区域扩大，小于区的下一个元素和a[i]交换，同时i自增</span><br><span class="line">      a[i] = p 时则等于区扩大，i自增</span><br><span class="line">      a[i] &gt; p 时则i保持不变，大于区前一个数和a[i]交换，大于区扩大</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">  step3：将partition过程等于区域的index数组[<span class="number">3</span>, <span class="number">3</span>]返回用于下一次递归即可</span><br><span class="line"></span><br><span class="line">  额外空间复杂度 <span class="built_in">O</span>(N*logN)，用于保存partition过程中树的节点</span><br></pre></td></tr></table></figure></li>
<li>实现：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> r_index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[r_index], a[r]);</span><br><span class="line">        <span class="keyword">int</span> *parr = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">        <span class="built_in">quickSort</span>(a, l, parr[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(a, parr[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> *parr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> m = l;</span><br><span class="line">    <span class="keyword">while</span> (m &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[m] &lt; a[r])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[++less], a[m++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[m] == a[r])&#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[m], a[--more]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[r], a[more]);</span><br><span class="line">    parr[<span class="number">0</span>] = less + <span class="number">1</span>;</span><br><span class="line">    parr[<span class="number">1</span>] = more;</span><br><span class="line">    <span class="keyword">return</span> parr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>master公式普及<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(N) = a * <span class="built_in">T</span>(N / b) + <span class="built_in">O</span>(N^d)</span><br><span class="line">(<span class="number">1</span>) <span class="built_in">logb</span>(a) = d 则 <span class="built_in">T</span>(N) = N^d * <span class="built_in">logN</span></span><br><span class="line">(<span class="number">2</span>) <span class="built_in">logb</span>(a) &gt; d 则 <span class="built_in">T</span>(N) = N^<span class="built_in">logb</span>(a)</span><br><span class="line">(<span class="number">3</span>) <span class="built_in">logb</span>(a) &lt; d 则 <span class="built_in">T</span>(N) = N^d</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找学习总结</title>
    <url>/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文总结二分查找算法，其实该算法的思想是很简单的。即在有序的线性存储结构中进行查找。</p>
<blockquote>
<ol>
<li>选择<code>mid</code>位置的元素<code>x</code>是否等于<code>target</code>，相等则终止查找；</li>
<li>若<code>x &lt; target</code>则需要向右半区间查找，更新<strong>左</strong>边界；</li>
<li>若<code>x &gt; target</code>则需要向左半区间查找，更新<strong>右</strong>边界;</li>
<li>重复前面几步直到不能再划分为止。</li>
</ol>
</blockquote>
<h1 id="1-关键点：查询的边界确定问题"><a href="#1-关键点：查询的边界确定问题" class="headerlink" title="1. 关键点：查询的边界确定问题"></a>1. 关键点：查询的边界确定问题</h1><p><strong>循环不变量的确定</strong>：即每次查询的左右区间维持一致，确保查询不重不漏</p>
<h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><ul>
<li>左闭右闭写法 <strong>[left, right]</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;    <span class="comment">// key：决定了[l, r]查找</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123; <span class="comment">// 需要更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123; <span class="comment">// 需要更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>左闭右开写法 <strong>[left, right)</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;    <span class="comment">// key：决定了[l, r)查找</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找应用1</title>
    <url>/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A81/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<ul>
<li>要求：时间复杂度为 O(log n)   </li>
<li>例子：<ul>
<li>输入: nums = [1,3,5,6], target = 5    输出: 2</li>
<li>输入: nums = [1,3,5,6], target = 2    输出: 1</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/">leetcode链接</a><h1 id="解法：改写二分"><a href="#解法：改写二分" class="headerlink" title="解法：改写二分"></a>解法：改写二分</h1></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123; <span class="comment">// 用于判断左边界 比如[1,3,5,6] target=0</span></span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找应用2</title>
    <url>/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A82/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<ul>
<li>要求：时间复杂度为 O(log n)   </li>
<li>例子：<ul>
<li>输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]</li>
<li>输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1]</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode链接</a></li>
</ul>
<h1 id="解法：改写二分"><a href="#解法：改写二分" class="headerlink" title="解法：改写二分"></a>解法：改写二分</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindLeft</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">FindLeft</span>(nums, target);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">FindRight</span>(nums, target);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2021/09/25/KMP/</url>
    <content><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>KMP算法的用处是为了加快<strong>子串match_str</strong>在<strong>母串orign_str</strong>中匹配查找的过程，如果匹配到则返回<strong>match_str</strong>在<strong>orign_str</strong>中的下标位置，如果没有则返回-1。</p>
<ul>
<li>如果假设母串的长度是<strong>N</strong>，子串的长度是<strong>M</strong>，则可以看出时间复杂度的差距之大：<ul>
<li>暴力解法：O(N*M)</li>
<li>KMP解法：O(N)</li>
</ul>
</li>
</ul>
<h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><p>既然想知道KMP算法优化了哪里，首先要知道常规的暴力解法慢在哪里，这样才能搞明白为什么KMP真正的进行性能提升。</p>
<p>假设现在有<strong>母串orign_str</strong>和<strong>子串match_str</strong></p>
<p><strong>orign_str  = “1234abc1234defk1234abc1234xyz789”</strong></p>
<p><strong>match_str= “1234abc1234xyz”</strong></p>
<h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><p>所谓暴力匹配就是从左到右一个一个字符的匹配，相同就都向后跳；一旦不同，子串从头开始和母串上一次的下一个字符开始匹配重复之前的过程直到结束。</p>
<p><strong>时间复杂度：O(M*N)</strong></p>
<p>上述的例子：</p>
<ul>
<li>开始 origin_str[i++] 和 match_str[j++] 进行比较，直到字符d≠x停止</li>
<li>接着 origin_str[1] 和 match_str[0] 再进行比较，不相等</li>
<li>接着 match_str[2] 和  match_str[0] 再进行比较，不相等</li>
<li>…..</li>
<li>match_str[7] 和 match_str[0] 相等，直到字符d≠a停止</li>
<li>接着match_str[11] = ‘d’ 接着和 match_str[0] 比较，不相等</li>
<li>接着match_str[12] = ‘e’ 接着和 match_str[0] 比较，不相等</li>
<li>…..</li>
<li>match_str[15] 和 match_str[0] 相等，直到子串匹配完成，返回母串下标idx = 15</li>
</ul>
<p><strong>根据上述的简易流程可以明显看出冗余许多无效匹配，这正是KMP进行优化的地方。</strong></p>
<h2 id="2-2-KMP解法"><a href="#2-2-KMP解法" class="headerlink" title="2.2 KMP解法"></a>2.2 KMP解法</h2><h3 id="2-2-1-基础知识：字符串的最大前缀，最大后缀"><a href="#2-2-1-基础知识：字符串的最大前缀，最大后缀" class="headerlink" title="2.2.1 基础知识：字符串的最大前缀，最大后缀"></a>2.2.1 基础知识：字符串的最大前缀，最大后缀</h3><ul>
<li>最大前缀：不包含最后一个字符</li>
<li>最大后缀：不包含第一个字符</li>
</ul>
<p>例子：str = “123b”，对于b这字符的最大前缀是“12”，最大后缀是“23”</p>
<h3 id="2-2-2-next数组：用于KMP优化的核心点"><a href="#2-2-2-next数组：用于KMP优化的核心点" class="headerlink" title="2.2.2 next数组：用于KMP优化的核心点"></a>2.2.2 <strong>next数组</strong>：用于KMP优化的核心点</h3><ul>
<li>定义：是根据子串建立的数组，表达的是最大前缀和最大后缀二者相匹配的长度</li>
<li>人为规定：<ul>
<li>next[0] = -1</li>
<li>next[1] = 0</li>
</ul>
</li>
</ul>
<p>例子：字符串str1 = “aaaab”，则next[5] = {-1, 0, 1, 2, 3}</p>
<h3 id="2-2-3-KMP是如何加速了匹配流程的呢？"><a href="#2-2-3-KMP是如何加速了匹配流程的呢？" class="headerlink" title="2.2.3 KMP是如何加速了匹配流程的呢？"></a>2.2.3 <strong>KMP是如何加速了匹配流程的呢？</strong></h3><p>继续使用之前的例子：</p>
<p><strong>orign_str  = “1234abc1234defk1234abc1234xyz789”，指针p1</strong></p>
<p><strong>match_str= “1234abc1234xyz”，指针p2</strong></p>
<ul>
<li>当第一次匹配到 d ≠ x 时，需要做下面的事情：<ul>
<li>根据 match_str 的 next 数组 x 字符所处下标的 next 数组值为4</li>
<li>p2指针跳转到 match_str[4] 处继续和 orign_str 中的d字符进行匹配<ul>
<li>match_str[4] ≠ ‘d’，则需要p2指针继续根据 next 数组向前跳转到 p2 = next[4] = 0 进行匹配</li>
<li>match_str[0] = “1” ≠ ‘d’，此时 next[p2] = -1，表示子串的第一个字符都已经和’d’字符不相等了，则母串的指针p1只能是继续右移了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上过程就是加速的过程，保证了母串的指针p1不会向前跳转，一直向后增长，时间复杂度降到O(N)。</p>
<ul>
<li>代码实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">const</span> string&amp; orign_str, <span class="keyword">const</span> string&amp; match_str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, len1 = orign_str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>, len2 = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">get_next_arr</span>(match_str);</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (orign_str[p1] == match_str[p2]) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (next[p2] == <span class="number">-1</span>) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = next[p2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2 == len2 ? (p1 - p2) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题记录</li>
</ul>
<p><img src="/2021/09/25/KMP/Untitled.png" alt="0"></p>
<ul>
<li><strong>Q1：为什么在X ≠ Y 的时候要将 match_str 中的 Z 去和 X 比较？</strong><br>X ≠ Y 发生的时候，根据 match_str 的 next 数组可以得知 partA == partB，所以直接舍弃 orign_str 字符串中 J 之前的部分，不再进行比较，直接将逻辑上看着就是直接将 match_str 推送到  orign_str 字符串中 J 位置上，而 partC == partB， 则 partA == partC 无需再比较，直接比较X和Z即可。</li>
<li><strong>Q2：为什么可以直接抛弃掉 orign_str 字符串中 J 之前的部分？真的不会匹配出一个 match_str 吗？</strong><br>假设这段有一个位置K，从此位置开始可以匹配出一个 match_str，则必然 [K, X] 这一段范围的字符串是存在于match_str中的，因为第一次匹配的时候是一路匹配下来的，按照这样则 match_str 的 next 数组值应该区域更大，和现有的发生矛盾，则证明一定可以抛弃。</li>
</ul>
<h3 id="2-2-4-next数组的求解"><a href="#2-2-4-next数组的求解" class="headerlink" title="2.2.4 next数组的求解"></a>2.2.4 next数组的求解</h3><p>前面的next数组的值求取是依赖其位置字符的最大前缀和最大后缀的相同的长度，没有说如何快速生成，一直当作一个黑盒在使用。</p>
<p>其实 i 位置的值是依赖 i-1 位置的值，所以根据下图得知：</p>
<p><img src="/2021/09/25/KMP/Untitled_1.png" alt="1"></p>
<p>求取 i 位置的值，只需要判断 b 的 next[] 值的下一个字符即 ？是否和字符 b 相等即可</p>
<ul>
<li>相等，则next[a] = next[b] + 1</li>
<li>不等，则前推；若一直推到 index = 0 处还没有相等的，则为 0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_next_arr</span><span class="params">(<span class="keyword">const</span> string&amp; match_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">assign</span>(len, <span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (match_str[i - <span class="number">1</span>] == match_str[cn])&#123;</span><br><span class="line">            next[i++] = ++cn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-完整代码测试"><a href="#2-2-5-完整代码测试" class="headerlink" title="2.2.5 完整代码测试"></a>2.2.5 完整代码测试</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_next_arr</span><span class="params">(<span class="keyword">const</span> string&amp; match_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">assign</span>(len, <span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (match_str[i - <span class="number">1</span>] == match_str[cn])&#123;</span><br><span class="line">            next[i++] = ++cn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">const</span> string&amp; orign_str, <span class="keyword">const</span> string&amp; match_str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, len1 = orign_str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>, len2 = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">get_next_arr</span>(match_str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;next arr value: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n---------------\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (orign_str[p1] == match_str[p2]) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (next[p2] == <span class="number">-1</span>) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = next[p2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2 == len2 ? (p1 - p2) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string orign_str = <span class="string">&quot;1234abc1234defk1234abc1234xyz789&quot;</span>;</span><br><span class="line">    string match_str = <span class="string">&quot;1234abc1234xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">get_index</span>(orign_str, match_str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;match_str in orign_str index: &quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/2021/09/25/KMP/Untitled_2.png" alt="2"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-String</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2021/10/03/Manacher/</url>
    <content><![CDATA[<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>用于求取字符串中最大的回文子串，需要考虑的是奇回文 or 偶回文</p>
<ul>
<li>奇回文：123a321，其中字符a所处的位置为对称轴，实轴</li>
<li>偶回文：1221，其中两个2中间的位置为对称轴，虚轴</li>
</ul>
<p>所以在判断回文串时需要先处理一下字符串本身，让虚轴显示出来，比如加入特殊字符”#”来保证虚轴可以看到。</p>
<ul>
<li>不用担心特殊字符和字符串中的原字符发生冲突，因为是对称的，虚轴只会和虚轴相比较。</li>
<li>处理过后的样子：<ul>
<li>奇回文：#1#2#3#a#3#2#1#</li>
<li>偶回文：#1#2#2#1#</li>
</ul>
</li>
</ul>
<h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><p>假设字符串的长度是N，处理成特殊字符后每个位置都开始向两边扩，比较字符，记录好最大的回文长度就ok，每次有更大的就更新。</p>
<ul>
<li>时间复杂度O(N^2)</li>
</ul>
<h2 id="2-2-manancher解法"><a href="#2-2-manancher解法" class="headerlink" title="2.2 manancher解法"></a>2.2 manancher解法</h2><p>解决掉在暴力解法中一些地方无需尝试扩，比较，直接向后跳即可。</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><p>要先熟悉几个概念</p>
<ul>
<li><strong>回文半径</strong></li>
<li><strong>最右回文边界R</strong>（R一定停在特殊字符上，因为只有实际字符才存在不同，扩不动的情况）</li>
<li><strong>最有回文边界的中心C</strong>（只记录第一次【即最早】冲到R时候的C的位置，此时为最长情况）</li>
</ul>
<h3 id="几种拓扑图（核心）"><a href="#几种拓扑图（核心）" class="headerlink" title="几种拓扑图（核心）"></a>几种拓扑图（核心）</h3><p>初始化遍历字符串的下标 Index = 0</p>
<ol>
<li>最右回文边界 R 在 Index 的左边，即 R &lt; Index <img src="/2021/10/03/Manacher/Untitled.png" alt="Untitled"> <strong>这种情况下没有优化空间，只能暴力匹配</strong></li>
<li>最右回文边界 R 在 Index 的右边，即 R &gt; Index<ol>
<li>Index 位置的对称点 <strong>Index’</strong> 的回文范围就在 <strong>(L，R)</strong> 内 <img src="/2021/10/03/Manacher/Untitled1.png" alt="Untitled"> <img src="/2021/10/03/Manacher/Untitled2.png" alt="Untitled"> 由图可以知道在对称点 <strong>Index’</strong> 的位置已经扩到了 <strong>X ≠ Y</strong> 处不能再向两边扩了。而目前Center所处的位置 <strong>C</strong> 所扩到最大的边界时<strong>（L，R）</strong>，所以 P == Y, Q == X。而 X ≠ Y，则 P  ≠ Q</li>
<li>Index位置的对称点 <strong>Index’</strong> 的回文范围只有部分在 <strong>(L，R)</strong> 内 <img src="/2021/10/03/Manacher/Untitled3.png" alt="Untitled"> <img src="/2021/10/03/Manacher/Untitled4.png" alt="Untitled"> 此时Index能扩充的范围就是（Index，R）。原因：<ul>
<li>由图可知目前 Center 所处的位置 <strong>C</strong> 所扩到最大的边界时<strong>（L，R）</strong>，所以 P ≠ Q。</li>
<li>而P在（i’L，i’R）这个当时以 <strong>Index’</strong> 为中心的回文串中，则一定有一个 X 和 P 关于<strong>Index’</strong> 对称，即 P == X</li>
<li>X 又在以 C 为中心的回文串（L，R）中，则必存在一个 Y 和 X 关于 C 对称，即X == Y</li>
<li>因为 P == X，X == Y，所以 P == Y，而 P ≠ Q，则Y≠Q，所以最多扩到<strong>（Index，R）</strong></li>
</ul>
 <strong>为什么（Index，R）就一定是回文呢？</strong><ul>
<li>因为关于C对称</li>
</ul>
</li>
<li>Index位置的对称点 <strong>Index’</strong> 的回文范围 (i’L，i’R) 中的 <strong>i’L</strong> 刚好和 (L，R) 的<strong>L重合</strong> <img src="/2021/10/03/Manacher/Untitled5.png" alt="Untitled"> <img src="/2021/10/03/Manacher/Untitled6.png" alt="Untitled"> 由图可以知道 ：<ul>
<li>X == Y</li>
<li>W ≠ Y，则 W ≠ X</li>
<li>W ≠ Z</li>
<li>但是无法确认Z是否等于X，则只能暴力扩展去判断</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h3><ul>
<li>case1：i 在 R 右面，暴力扩，i增长，时间复杂度O(n)</li>
<li>case2：（i’L，i’R）在L内，不用扩，O(1)</li>
<li>case3：（i’L，i’R）部分在L内，即 i’L &lt; L &lt; i’R &lt; R，不用扩，O(1)</li>
<li>case4： i’L  == L，重合，i增长， O(n)</li>
</ul>
<p>可见只有case1 和case4 需要扩，字符串长度为n，则为O(n)</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 慎用，string累加时在处理拷贝内存时耗时很大</span></span><br><span class="line"><span class="function">string <span class="title">manacher_string</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        res = res + s[i] + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">manacher_string_2</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    string res;</span><br><span class="line">    res.<span class="built_in">resize</span>(len);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        res[i] = (i&amp;<span class="number">1</span>)==<span class="number">0</span> ? <span class="string">&#x27;#&#x27;</span> : s[idx++];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max_len_of_sub_str</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string manacher_str = <span class="built_in">manacher_string</span>(s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;manacher_str: &quot;</span> &lt;&lt; manacher_str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> manacher_str_len = manacher_str.<span class="built_in">length</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;manacher_str_len: &quot;</span> &lt;&lt; manacher_str_len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> pArr[manacher_str_len];  <span class="comment">// 回文数组，记录该位置的回文子串R是多大</span></span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_range = INT_MIN;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pArr[i] = R &gt; i ? min(pArr[2*C - i], R - i) : 1;</span></span><br><span class="line"><span class="comment">     * 该行对case1 case2 case3进行了整合, 确定了起码的回文半径</span></span><br><span class="line"><span class="comment">     * 分析case1时，i 在 R 的右边，则R &gt; i 不成立，pArr[i] = 1,则: </span></span><br><span class="line"><span class="comment">     *      (i+1 &lt; len) &amp;&amp; (i-1 &gt; -1) 条件成立，进入while向右扩</span></span><br><span class="line"><span class="comment">     * 分析case2 和 case3时，知道扩不动，时间复杂度O(1)，然后再尝试扩一下，时间复杂度也是O(1)</span></span><br><span class="line"><span class="comment">     *      取i位置对称点i&#x27;的最大回文半径pArr[2*C-i] 和[i, R]这段的最小值为pArr[i]</span></span><br><span class="line"><span class="comment">     *      进入while第1下就break，因为明确的知道 i+pArr[i] 处字符一定不等于 i-pArr[i]处字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manacher_str_len; ++i)&#123;</span><br><span class="line">        pArr[i] = R &gt; i ? <span class="built_in">min</span>(pArr[<span class="number">2</span>*C - i], R - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + pArr[i] &lt; manacher_str_len &amp;&amp; i - pArr[i] &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (manacher_str[i + pArr[i]] == manacher_str[i - pArr[i]])&#123;</span><br><span class="line">                pArr[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + pArr[i] &gt; **R)&#123;</span><br><span class="line">            R = i + pArr[i];    <span class="comment">// R是最大回文子串的长度，不是字符串的下标</span></span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        max_range = <span class="built_in">max</span>(max_range, pArr[i]); <span class="comment">// 记录一个最大的回文长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_range - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-String</tag>
      </tags>
  </entry>
  <entry>
    <title>BFPRT</title>
    <url>/2021/10/06/BFPRT/</url>
    <content><![CDATA[<h1 id="BFPRT"><a href="#BFPRT" class="headerlink" title="BFPRT"></a>BFPRT</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>用于解决TopK问题。</p>
<ul>
<li>TopK问题：从长度为N的<strong>无序数组</strong>中找出前K大的数</li>
<li>BFPRT算法：1973年，由5位科学家 Blum 、 Floyd 、 Pratt 、 Rivest 、 Tarjan发表了一篇 <a href="https://people.csail.mit.edu/rivest/BlumFloydPrattRivestTarjan-TimeBoundsForSelection.pdf">“Time bounds for selection”</a> 的论文，讲述了如何选取第K大的元素，也称为”Median of medians”，即中位数的中位数算法。<strong>该算法的时间复杂度可以严格收敛到O(n)级别。</strong></li>
</ul>
<h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><p>假设现在存在一个函数 GetKthNum(arr[], k)  可以获取到第k大的数，这个函数中要做哪些事情：</p>
<ul>
<li>数组的长度为n，则每5个划分为1组，不够5个元素的单独成组，一共由n/5组。时间复杂度：O(1)</li>
<li>每5个数在组内排序，组与组之间无序。时间复杂度：O(1) * n / 5 = O(n)</li>
<li>将排好序的每组中的<strong>上中位数</strong>取出来单独成组MediansArr，该组的长度为n/5。然后递归的调用GetKthNum(MediansArr, n/10) 函数，目的是为了获取到中位数数组的中位数Pivot。<ul>
<li>上中位数：（1，2，3，4，5）取3，（1，2，3，4）取2</li>
<li>为什么是n/10，因为数组的长度是n/5，其中位数的一定是处于n/10的位置。</li>
<li>时间复杂度：自己调用自己，T(n/5)</li>
</ul>
</li>
<li>此时用Pivot去进行快排中提到的 partition 过程，时间复杂度：O(n)<ul>
<li>&lt; Pivot 的数放在左边</li>
<li>= Pivot 的数放在中间</li>
<li><blockquote>
<p>Pivot 的数放在右边</p>
</blockquote>
</li>
</ul>
  将返回的等于区域数组pArr，判断是否命中K<ul>
<li>pArr[0] == K，停止</li>
<li>pArr[0] &gt; K，左半部分进行递归</li>
<li>pArr[0] &lt; K，右半部分进行递归</li>
</ul>
</li>
<li>上面的递归过程每次都可以严格的淘汰掉至少n*3/10的数据量，看图很容易明白：  <img src="/2021/10/06/BFPRT/Untitled.png" alt="Untitled">  一共有n/5组，中位数数组的中位数值为Pivot，在该数组中有n/10个数的值比Pivot小，这些数字在各自的小数组中又是中位数，则表示这些组每组存在3/5个数比Pivot小，所以在原数组中就至少有<strong>n*3/10</strong>的数据量比Pivot小。也就是最多<strong>n*7/10</strong>有比Pivot大，确定了递归规模。</li>
<li>整体时间复杂度T(n) = T(n/5) + T(n*7/10) + O(n)，可以收敛到O(n)，证明（<a href="https://zhuanlan.zhihu.com/p/291206708">参考链接</a>）如下：  <img src="/2021/10/06/BFPRT/Untitled1.png" alt="Untitled"></li>
</ul>
<h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><h2 id="3-1-Partition过程回顾"><a href="#3-1-Partition过程回顾" class="headerlink" title="3.1 Partition过程回顾"></a>3.1 Partition过程回顾</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; equals;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> m = l;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[m] == pivot) &#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[more--], arr[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++less], arr[m++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    equals.<span class="built_in">push_back</span>(less + <span class="number">1</span>);</span><br><span class="line">    equals.<span class="built_in">push_back</span>(more);</span><br><span class="line">    <span class="keyword">return</span> equals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-BFPRT实现"><a href="#3-2-BFPRT实现" class="headerlink" title="3.2 BFPRT实现"></a>3.2 BFPRT实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">get_min_kth_nums_by_bfprt</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; len)   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> kth_num_val = <span class="built_in">get_indexth_num_of_arr</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> ik = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= kth_num_val)</span><br><span class="line">        &#123;</span><br><span class="line">            res[ik++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_indexth_num_of_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> arr[l];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">get_median_of_medians_arr</span>(arr, l, r);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;------------p------------&quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span>* part_res = <span class="built_in">partition</span>(arr, l, r, p);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;part_res [0] = &quot; &lt;&lt; part_res[0] &lt;&lt; &quot;, part_res[1] = &quot; &lt;&lt; part_res[1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= part_res[<span class="number">0</span>] &amp;&amp; index &lt;= part_res[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &lt; part_res[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_indexth_num_of_arr</span>(arr, l, part_res[<span class="number">0</span>] - <span class="number">1</span>, index);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_indexth_num_of_arr</span>(arr, part_res[<span class="number">1</span>] + <span class="number">1</span>, r, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; p)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++less], arr[i++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; p)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[more--], arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *part = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    part[<span class="number">0</span>] = less + <span class="number">1</span>;</span><br><span class="line">    part[<span class="number">1</span>] = more;</span><br><span class="line">    <span class="keyword">return</span> part;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_median_of_medians_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> offset = count % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> medians_arr_len = count / <span class="number">5</span> + offset;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;medians_arr_len: &quot; &lt;&lt; medians_arr_len &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> medians_arr[medians_arr_len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; medians_arr_len; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> part_begin = l + <span class="number">5</span> * i;</span><br><span class="line">        <span class="keyword">int</span> part_end = <span class="built_in">min</span>((part_begin + <span class="number">4</span>), r);</span><br><span class="line">        medians_arr[i] = <span class="built_in">get_median</span>(arr, part_begin, part_end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;medians_arr has: &quot;;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt;  medians_arr_len; ++i)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; medians_arr[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_indexth_num_of_arr</span>(medians_arr, <span class="number">0</span>, medians_arr_len - <span class="number">1</span>, medians_arr_len / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_median</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. insert sort </span></span><br><span class="line">    <span class="built_in">insert_sort</span>(arr, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 2. return arr[mid]</span></span><br><span class="line">    <span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; l; --j)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algo-TopK</tag>
      </tags>
  </entry>
  <entry>
    <title>基础计算机网络</title>
    <url>/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络和互联网"><a href="#计算机网络和互联网" class="headerlink" title="计算机网络和互联网"></a>计算机网络和互联网</h1><ul>
<li>什么是Internet ?<ul>
<li>节点：主机，路由器，交换机</li>
<li>边：通信链路</li>
</ul>
</li>
<li>什么是协议?<ul>
<li>通信过程中需要遵守的规则集合，如TCP，IP，FTP，HTTP等。<ul>
<li>格式</li>
<li>次序</li>
</ul>
</li>
</ul>
</li>
<li>网络边缘<ul>
<li>主机</li>
<li>应用程序<ul>
<li>应用通信模式：<ul>
<li>CS模式</li>
<li>对等模式（peer to peer）</li>
</ul>
</li>
<li>传输方式：<ul>
<li>TCP<ul>
<li>三次握手建立连接</li>
<li>可靠数据传输：确认机制，重传机制</li>
<li>流量控制：防止发送方淹没接收方</li>
<li>拥塞控制：网络速率降低时，发送方降低发送速率</li>
<li>应用：HTTP，FTP</li>
</ul>
</li>
<li>UDP<ul>
<li>无连接</li>
<li>不可靠</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
<li>应用：流媒体，远程会议，DNS</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>接入网、物理媒体<ul>
<li>接入网<ul>
<li>有线 or 无线通信链路</li>
<li>网络带宽bps（bits per second）</li>
<li>接入网的方式<ul>
<li>原来方式：调制解调器<strong>modem（猫），</strong>借用电话线，完成将电路信号转为网络信号。<ul>
<li>缺点：带宽很小，上网电话不能同时使用</li>
</ul>
</li>
<li>改进：原有的模式<ul>
<li>0~4kHz用于电话</li>
<li>4kHz以上仍然使用调制和反调制的模式，非对称分割（一段用于上传，一段用于下载）</li>
</ul>
</li>
<li>现有方式：铺专线，光纤入户</li>
</ul>
</li>
</ul>
</li>
<li>物理媒体<ul>
<li>导引型媒体（看得到摸得着）<ul>
<li>同轴电缆</li>
<li>光纤（安全）</li>
<li>双绞线</li>
</ul>
</li>
<li>非导引型媒体（开放的空间无形的）<ul>
<li>电磁波</li>
<li>光信号</li>
<li>卫星</li>
<li>wide-area<ul>
<li>3G，4G，5G</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>网络核心：互相连着的路由器，起着数据交换的作用<ul>
<li>分组交换（互联网大多使用此）<ul>
<li>存储转发<ul>
<li>不存储转发就变成网络独享了，不能共享</li>
</ul>
</li>
<li>虚电路网络（TCP）</li>
<li>数据表网络（UDP）</li>
</ul>
</li>
<li>线路交换（电路交换，用于电话网）<ul>
<li>时分</li>
<li>频分</li>
<li>波分</li>
<li>码分（CDM）<ul>
<li>采用接入的方式称为CDMA</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Internet/ISP 结构<ul>
<li>端接入ISPs（Internet Service Providers）连接到互联网</li>
<li>ISPs之间必须互联<ul>
<li>每两个连接不可取， 复杂度：$O（n^2）$</li>
<li>分治，区域性互相连接即可  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0.png" alt="Untitled">  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png" alt="Untitled"></li>
</ul>
</li>
</ul>
</li>
<li>性能：丢包、延时、吞吐量<ul>
<li>分组丢失和延时的发生原因：<ul>
<li>分组到达链路的速率超过了链路输出能力</li>
<li>分组排队，传输时延</li>
</ul>
</li>
<li>丢包<ul>
<li>取决于路由器的缓冲队列的大小。不可能无限大，尽管不丢包，但是体验感差</li>
</ul>
</li>
<li>延时<ul>
<li>节点处理时延：检测bit差错，分析首部决定发向哪里</li>
<li>排队时延：路由器的拥塞程度</li>
<li>传输时延：链路 带宽R，分组长度L，时延值= $L / R$，称为存储转发时延</li>
<li>传播时延：耗费在链路上的传播时延，链路长度d，传播速度s，时延值=$d/s$</li>
</ul>
</li>
<li>吞吐量<ul>
<li>源端和目标端之间的传输数据量（数据量/单位时间）<ul>
<li>瞬间吞吐量：某个时间点</li>
<li>平均吞吐量：某个时间段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>协议层次、服务模型<ul>
<li>服务类型<ul>
<li>面向连接TCP</li>
<li>无连接 UDP</li>
</ul>
</li>
<li>协议层次<ul>
<li>PDU：协议数据单元<ul>
<li>头部 + （n+1）层的SDU（Service Data Unit）</li>
<li>当SDU太大时需要分片，加上头部变成多个PDU；SDU太小时，多个组合起来加一个头部变成PDU；</li>
</ul>
</li>
<li>网络层次<ul>
<li>应用层：报文message</li>
<li>传输层：报文段：TCP段，UDP数据报</li>
<li>网络层：分组Packet，无连接时为数据包datagram，在链路层点到点之间的服务之上提供了端到端的服务</li>
<li>链路层：帧frame</li>
<li>物理层：位bit</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><ul>
<li>应用层协议原理</li>
<li>Web和HTTP</li>
<li>FTP</li>
<li>Email（SMTP，POP3，IMAP）</li>
<li>DNS</li>
<li>P2P应用</li>
<li>CDN（内容分发网络 Content Delivery Network）<ul>
<li>视频流量占用大部分的带宽，如何并发的为那么多用户提供服务？挑战点：<ul>
<li>规模性：单服务器无法服务大量用户</li>
<li>异构性：不同用户有不同的能力，比如有线接入和无线接入，其带宽容量不同</li>
</ul>
</li>
<li>存储视频的流化方式（DASH动态自适应协议：Dynamic Adaptive Streaming over HTTP）：上线视频时，预先部署，设置成不同清晰度的版本，分成每一块，设置URL放置到告示文件（manifest file）中供client去获取，也可以保证在观看中动态的切换清晰度，流化服务。<ul>
<li>client首先要获取manifest file，然后解析</li>
<li>解析完成后根据自己的需求，网络的带宽，缓存能力等实时情况动态调整去各个服务器获取每个块的流化信息</li>
<li>各个块的流化信息是预先部署到服务器上的。</li>
</ul>
</li>
<li>单个服务器的问题有哪些？<ul>
<li>client访问到svr的路由器跳数太多</li>
<li>重复的流量太多，浪费网络资源</li>
<li>单点故障</li>
<li>周边网络拥塞</li>
</ul>
</li>
<li>解决方案：CDN<ul>
<li>分布式的部署到各个地点Cache Server</li>
<li>预先将内容存储到这些Cache Server</li>
<li>用户访问Svr时，根据域名解析重定向到距离用户最近的Cache Server</li>
</ul>
</li>
<li>CDN部署策略：<ul>
<li>local ISP<ul>
<li>优点：距离用户最近，服务质量高</li>
<li>缺点：节点太多，维护费用高</li>
</ul>
</li>
<li>bring home<ul>
<li>优点：节点少，只选择关键的位置，也距离用户不算远，服务质量不错</li>
<li>缺点：client访问经过路由器跳数略多</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h2><ul>
<li>数据结构 <strong>hostent</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="keyword">char</span> 	*h_name; <span class="comment">// 主机域名</span></span><br><span class="line">	<span class="keyword">char</span> 	**h_aliases; <span class="comment">// 主机域名别名</span></span><br><span class="line">	<span class="keyword">int</span>	 	h_addrtype; <span class="comment">//  主机ip地址类型，ipv4(AF_INET) ipv6(AF_INET6)</span></span><br><span class="line">	<span class="keyword">int</span> 	h_length; 		<span class="comment">// ip地址的长度</span></span><br><span class="line">	<span class="keyword">char</span> 	**h_addr_list; <span class="comment">// 主机的ip地址 (以网络字节序存储)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 该函数通过域名获取IP地址，Client端调用该函数获取Server端的IP</span></span><br><span class="line"><span class="comment">* 传入参数：域名 or 主机名</span></span><br><span class="line"><span class="comment">* 返回值：</span></span><br><span class="line"><span class="comment">	成功返回：struct hostent结构体</span></span><br><span class="line"><span class="comment">	失败返回: NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </span><br></pre></td></tr></table></figure>
</li>
<li>数据结构 <strong>sockaddr_in</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> **<span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">		<span class="keyword">short</span> sin_family; <span class="comment">// 地址族</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port; <span class="comment">// port</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IP地址</span></span><br><span class="line">		<span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// 对齐</span></span><br><span class="line">&#125;;** </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;  <span class="comment">// load with inet_aton()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>数据结构 <strong>sockaddr</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>  sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="keyword">char</span>         sa_data[<span class="number">14</span>];  <span class="comment">//IP地址和端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>sockaddr</strong> 和 <strong>sockaddr_in</strong> 的区别  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.png" alt="Untitled">  sockaddr 和 sockaddr_in 的长度相同，都是16字节，只是将IP地址和端口号合并到一起，用一个成员 sa_data 表示。要想给 sa_data 赋值，必须同时指明IP地址和端口号，例如”127.0.0.1:80“，遗憾的是，没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 sockaddr_in 来代替。这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。</li>
<li>Server端  <a href="https://man7.org/linux/man-pages/dir_section_3.html">https://man7.org/linux/man-pages/dir_section_3.html</a> (man手册)  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. domain：AF_INET、AF_INET6、AF_LOCAL</span></span><br><span class="line"><span class="comment">2. type：SOCK_STEAM、SOCK_DGRAM</span></span><br><span class="line"><span class="comment">3. protocol: 默认0，会根据type自动选择</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> welcome_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 用于监听client的请求</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">sin.sin_family = AF_INET;</span><br><span class="line">sin.sin_port = <span class="built_in">htons</span>(<span class="number">24</span>); </span><br><span class="line">sin.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY) <span class="comment">// INADDR_ANY表示本机的任意一个IP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">bind</span>(welcome_fd, (struct sockaddr*)&amp;sin, <span class="built_in"><span class="keyword">sizeof</span></span>(sin))</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123; <span class="comment">// 0 成功 -1 失败</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. svr端的socket fd</span></span><br><span class="line"><span class="comment">2. 限制套接字监听队列中未完成的连接数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">listen</span>(welcome_fd, <span class="number">5</span>); </span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123; <span class="comment">// 0 成功 -1 失败</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span>*)&amp;client_addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr));</span><br><span class="line"><span class="keyword">int</span> client_addr_len = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line"><span class="keyword">char</span> recv_buff[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 接收一个新的client连接</span></span><br><span class="line">	<span class="keyword">int</span> connect_client_fd = <span class="built_in">accept</span>(welcome_fd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">	<span class="built_in">recv</span>(connect_client_fd, recv_buff, <span class="built_in"><span class="keyword">sizeof</span></span>(recv_buff), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 处理请求</span></span><br><span class="line">	<span class="comment">// 封装信息，假设char* send_buf[]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 发送给client</span></span><br><span class="line">	<span class="comment">// https://man7.org/linux/man-pages/man3/send.3p.html</span></span><br><span class="line">	<span class="built_in">send</span>(connect_client_fd, send_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(send_buf), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">close</span>(connect_client_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.png" alt="本地字节序转化为网络字节序的函数，位于头文件&lt;arpa/inet.h&gt;中  [https://linux.die.net/man/3/htonl](https://linux.die.net/man/3/htonl)">  本地字节序转化为网络字节序的函数，位于头文件&lt;arpa/inet.h&gt;中  <a href="https://linux.die.net/man/3/htonl">https://linux.die.net/man/3/htonl</a></li>
<li>Client端  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">client_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STEAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">sin.sin_family = AF_INET;</span><br><span class="line">sin.sin_port = <span class="built_in">htons</span>(<span class="number">24</span>); </span><br><span class="line">sin.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY) <span class="comment">// INADDR_ANY表示本机的任意一个IP</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(client_fd, (struct sockaddr*)&amp;sin, <span class="built_in"><span class="keyword">sizeof</span></span>(sin));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> send_buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">char</span> recv_buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">send</span>(client_fd, send_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(send_buf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">recv</span>(client_fd, recv_buff, <span class="built_in"><span class="keyword">sizeof</span></span>(recv_buff), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>流程图  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.png" alt="Untitled"></li>
<li>TCP字节流的服务，不提供边界划分的功能，则需要应用层自己去设定协议解包</li>
</ul>
<h2 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h2><ul>
<li>无连接，不用握手，发送端在每一个报文中明确指定目标的IP和Port</li>
<li>服务器必须从收到的分组中提取出发送端的IP地址和Port</li>
<li>传输的数据可能乱序，可能丢失</li>
<li>Server端  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> svr_fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">sin.sin_family = AF_INET;</span><br><span class="line">sin.sin_port = <span class="built_in">htons</span>(<span class="number">24</span>); </span><br><span class="line">sin.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY) <span class="comment">// INADDR_ANY表示本机的任意一个IP</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span>(svr_fd, (struct sockaddr*)&amp;sin, <span class="built_in"><span class="keyword">sizeof</span></span>(sin));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="keyword">char</span> recv_buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">char</span> send_buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">recvfrom</span>(svr_fd, recv_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(recv_buf), <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;<span class="built_in"><span class="keyword">sizeof</span></span>(client_addr));</span><br><span class="line"><span class="built_in">sendto</span>(svr_fd, send_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(send_buf), <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr));</span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>Client端  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> client_fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">svr_addr</span>;</span></span><br><span class="line">svr_addr.sin_family = AF_INET;</span><br><span class="line">svr_addr.sin_port = <span class="built_in">htons</span>(<span class="number">24</span>); </span><br><span class="line">svr_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY) <span class="comment">// INADDR_ANY表示本机的任意一个IP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> send_buf[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">char</span> recv_buf[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">sendto</span>(client_fd, send_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(send_buf), <span class="number">0</span>, (struct sockaddr*)&amp;svr_addr,&amp;<span class="built_in"><span class="keyword">sizeof</span></span>(svr_addr));</span><br><span class="line"><span class="built_in">recvfrom</span>(client_fd, recv_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(recv_buf), <span class="number">0</span>, (struct sockaddr*)&amp;svr_addr, &amp;<span class="built_in"><span class="keyword">sizeof</span></span>(svr_addr));</span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/">Transmission versus Propagation Delay</a></p>
<h2 id="理解传输层的工作原理"><a href="#理解传输层的工作原理" class="headerlink" title="理解传输层的工作原理"></a>理解传输层的工作原理</h2><h3 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用 / 解复用"></a>多路复用 / 解复用</h3><ul>
<li>发送方：  从多个套接字<strong>Socket</strong>接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装(该头部信息用于以后的解复用)</li>
<li>接收方：  根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</li>
</ul>
<h3 id="可靠数据传输（RDT）原理"><a href="#可靠数据传输（RDT）原理" class="headerlink" title="可靠数据传输（RDT）原理"></a>可靠数据传输（RDT）原理</h3><ul>
<li>rdt 1.0</li>
<li>rdt 2.0<ul>
<li>ACK，继续发新的</li>
<li>NAK，发送旧的，直到收到ACK</li>
<li>问题：如果ACK，NAK丢失，则发送方则无法判断，不知所措</li>
</ul>
</li>
<li>rdt 2.1<ul>
<li>解决rdt 2.0的问题：增加序号，如果ACK or NAK出错，发送方仍发送旧的，如果接收方已经存在该序号，则丢掉，同时发送ACK；如果不存在则接收发送ACK</li>
<li>一次只发一个分组，等待确认，再发送下一个，称为停止等待协议</li>
</ul>
</li>
<li>rdt 2.2<ul>
<li>无NAK的协议，但是要对ACK编号，为流水线协议做好准备  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.png" alt="Untitled">  NAK1就等于前一个分组的ACK0，所以用重复的ACK0就可以替代NAK1的作用。</li>
<li>如果接收方发送的ACK出错，到达发送方后，发现有误，则重发上一个分组，接收方发现已经接收，丢掉，继续发ACK即可</li>
</ul>
</li>
<li>rdt3.0<ul>
<li>新的假设：具有比特差错和分组丢失的下层信道，导致丢失分组（数据<br>或ACK），发送P1时丢失，此时发送方等待ACK1，接收方等待P1，则形成死锁。  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.png" alt="Untitled"></li>
<li>解决方法：增加超时定时器，一旦到时则超时重传</li>
</ul>
</li>
<li>停止等待协议的问题：在信道容量比较大（以北京到深圳的高速公路为例子，中间可以容纳很多车，但两个收费站之间每次只通过一辆车，效率很低）的时候利用率太低，所以<strong>引出了流水线协议</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.png" alt="Untitled">  RTT = 30ms  分组长度1kB = 8k bits  链路带宽：1Gbps  利用率为$<code>Usender</code>$，问题在于协议发送的数据太少，增大未经确认的分组个数来提高信道的利用率。</li>
</ul>
<h3 id="滑动窗口协议（slide-window）"><a href="#滑动窗口协议（slide-window）" class="headerlink" title="滑动窗口协议（slide window）"></a>滑动窗口协议（slide window）</h3><ul>
<li>发送方窗口大小 = 1，接收方窗口 =1 的时候就是：停止等待协议</li>
<li>发送方窗口大小 &gt; 1 的时候就是：流水线协议<ul>
<li>接收方窗口 = 1 的时候就是 GBN 协议</li>
<li>接收方窗口 &gt; 1 的时候就是 SR 协议</li>
</ul>
</li>
</ul>
<h3 id="流水线协议（pipelined）"><a href="#流水线协议（pipelined）" class="headerlink" title="流水线协议（pipelined）"></a><strong>流水线协议（pipelined）</strong></h3><p>TCP采用的流水线协议一般是（GBN + SR）混用</p>
<p><a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/">Selective Repeat / Go Back N</a></p>
<ul>
<li><strong>GBN协议</strong>：如果12345发送，其中2号丢失，则需要2345重新发送</li>
</ul>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html">Go-Back Protocol</a></p>
<ul>
<li><strong>SR协议</strong>：如果12345发送，其中2号丢失，则只需重新发送2即可</li>
</ul>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html">Selective Repeat Protocol</a></p>
<h3 id="TCP超时定时器RTO的合理设置："><a href="#TCP超时定时器RTO的合理设置：" class="headerlink" title="TCP超时定时器RTO的合理设置："></a><strong>TCP超时定时器RTO的合理设置</strong>：</h3><ul>
<li>比RTT要长，RTT是变化的</li>
<li>太短会导致超时太早到达，造成不必要的重传</li>
<li>太长会导致报文丢失反应太慢</li>
<li>一般选择自适应的计算获取：超时时间 = RTT + 4 * 标准差RTT<ul>
<li>SampleRTT：测量从报文段发出到收到确认的时间</li>
<li>采样，计算SampleRTT的平均值EstimatedRTT，α一般取值0.125。  *<em>EstimatedRTT = (1- α)*<em>EstimatedRTT +</em> α*SampleRTT</em>*  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8.png" alt="Untitled"></li>
<li>计算 SampleRTT 距离 EstimatedRTT 的偏差程度的值X =【x1，x2，x3，…..，xn】，再求取X的平均值，相当于标准差。  <strong>DevRTT = (1-β) * <em>DevRTT +</em> β * | SampleRTT-EstimatedRTT |</strong> （绝对值）</li>
<li>RTO = EstimatedRTT  + 4 * DevRTT</li>
</ul>
</li>
</ul>
<h3 id="产生ACK的场景"><a href="#产生ACK的场景" class="headerlink" title="产生ACK的场景"></a>产生ACK的场景</h3><p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.png" alt="Untitled"></p>
<h3 id="重传分组的场景："><a href="#重传分组的场景：" class="headerlink" title="重传分组的场景："></a>重传分组的场景：</h3><ul>
<li>发送方超时定时器到时，则开始重传，该行为称为<strong>超时重传</strong>。</li>
<li>发送方收到连续的3个冗余ACK，此时还没有到达超时定时器的时间，但仍会触法重传，该行为称为<strong>快速重传。</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.png" alt="Untitled"></li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/">Flow Control</a></p>
<p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/flow-control/index.html">Flow Control</a></p>
<p>接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。通过捎带技术将缓冲区窗口大小携带给发送方，让发送方按照这个窗口大小发送字节流。</p>
<h3 id="TCP连接管理（三次握手-四次挥手）"><a href="#TCP连接管理（三次握手-四次挥手）" class="headerlink" title="TCP连接管理（三次握手 + 四次挥手）"></a>TCP连接管理（三次握手 + 四次挥手）</h3><ul>
<li><strong>2次握手建立连接的问题：</strong><ul>
<li>变化的延迟，连接请求的段没有丢，但是超时，超时定时器后继续发送建立连接，会导致服务器维护很多无效的半连接，浪费服务器的资源  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.png" alt="Untitled"></li>
<li><strong>由于丢失造成的重传，导致数据重发给服务器</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/12.png" alt="Untitled"></li>
</ul>
</li>
<li><strong>3次握手建立连接（解决上述两个问题）</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.png" alt="Untitled"><ul>
<li><strong>虚假的半连接被客户端拆除掉</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/14.png" alt="Untitled"></li>
<li><strong>老的数据不会被server端接收，直接丢掉</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/15.png" alt="Untitled"></li>
</ul>
</li>
<li><strong>四次挥手断开TCP连接</strong><ul>
<li>看作两个半连接的拆除</li>
<li>两军问题</li>
<li>客户端，服务器分别关闭它自己这一侧的连接，发送FIN bit = 1的TCP段，一旦接收到FIN，用ACK回应，接到FIN段，ACK可以和它自己发出的FIN段一起发送，可以处理同时的FIN交换  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/16.png" alt="Untitled"></li>
<li>注意上面图中的TIMED_WAIT状态，一般是2个MSL的时间，主要原因如下：<ul>
<li>原因1：要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。否则认为成功，可以转为closed状态</li>
<li>原因2：保证在该连接上的数据处理顺利完毕。如果一旦立刻关闭，重新以该Port再建立一个新的TCP连接，则新旧数据处理会混乱出现问题。所以留一段时间来保证网络中的遗留数据都处理完再释放资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><p>太多的数据通过网络传输，超过了网络的处理能力</p>
<ul>
<li>表现：<ul>
<li>分组丢失（路由器缓冲溢出）</li>
<li>分组经历比较长的延迟（在路由器中排队）</li>
</ul>
</li>
<li><strong>场景1：链路带宽R，2台主机，一个路由器具备无限大的缓冲</strong><ul>
<li>吞吐表现  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17.png" alt="Untitled"></li>
<li>延迟表现  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18.png" alt="Untitled"></li>
</ul>
</li>
<li>场景2：路由器缓冲区有限，会丢失分组，发送端重传  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/19.png" alt="Untitled"><ul>
<li>分组可能丢失，由于缓冲器满而被丢弃</li>
<li>发送端最终超时，发送第2个拷贝，2个分组都传到</li>
<li>为了达到一个有效输出，网络需要做更多的工作（重传）</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝：<ul>
<li>是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</li>
<li>降低了的“goodput”</li>
</ul>
</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20.png" alt="Untitled"></li>
<li>场景3：多台路由器，多台主机互传，会形成网络死锁  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/21.png" alt="Untitled"></li>
</ul>
<h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><ul>
<li>端到端的拥塞控制，TCP采用<ul>
<li>没有来自网络的显示反馈</li>
<li>端系统根据延迟和丢失事件推断是否有拥塞</li>
</ul>
</li>
<li>网络辅助的拥塞控制，一般用于ATM 银行网络 ABR（Available bit rate）<ul>
<li>路由器提供给端系统来反馈网络的拥塞情况<ul>
<li>单个bit置位，显示有拥塞</li>
<li>显示提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/tcp-congestion/index.html">TCP Congestion Control</a></p>
<ul>
<li>拥塞控制和流量控制是联合作用的，取二者的最小值来发送，使二者都满足<ul>
<li>$SendWin=min(CongWin, RecvWin)$</li>
</ul>
</li>
<li>每收到一个确认ACK，拥塞窗口值加1个MSS的大小；和每个RTT内拥塞窗口double翻倍的概念是一致的。<strong>如何理解</strong>：<ul>
<li>假设当前窗口是n，发送方一次发送n个包，每个包收到1个ACK，则这是一个RTT，收到n个ACK，则需要增加n个包，变为2*n。所以是每个RTT翻倍</li>
</ul>
</li>
<li>线性增，乘性减  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/22.png" alt="Untitled">  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/23.png" alt="Untitled"></li>
<li><strong>慢启动阶段称为SS</strong></li>
<li><strong>拥塞避免阶段称为CA</strong></li>
<li><strong>总结</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/24.png" alt="Untitled">  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25.png" alt="Untitled"></li>
</ul>
<h3 id="TCP的公平性"><a href="#TCP的公平性" class="headerlink" title="TCP的公平性"></a>TCP的公平性</h3><p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/26.png" alt="Untitled"></p>
<p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/27.png" alt="Untitled"></p>
<h2 id="学习传输层协议"><a href="#学习传输层协议" class="headerlink" title="学习传输层协议"></a>学习传输层协议</h2><ul>
<li>TCP：面向连接的字节流，提供可靠数据传输（Reliable Data Transfer）的服务，20字节头部<ul>
<li>序号：在MSS中的offset</li>
<li>确认号：发送方收到接收方ACK=6的话，表示接收方已经收到了5以前所有的报文，希望收到下一个字节的序号。</li>
<li>接收窗口：用于流量控制，表示能接收的字节数量</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/28.png" alt="Untitled"><ul>
<li>点对点<ul>
<li>一个发送方，一个接收方</li>
</ul>
</li>
<li>可靠的，按顺序的字节流<ul>
<li>没有报文边界</li>
</ul>
</li>
<li>管道化（流水线协议）<ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
</li>
<li>发送和接收缓存<ul>
<li>用于丢失重传</li>
</ul>
</li>
<li>全双工数据<ul>
<li>在同一连接中数据流向是双向流动</li>
<li>MSS：最大报文段大小，物理网络（比如以太网最长是1500字节 = TCP头部20字节 + IP头部20字节 + 数据1460字节）</li>
</ul>
</li>
<li>面向连接<ul>
<li>数据交换之前通过三次握手建立连接</li>
</ul>
</li>
<li>有流量控制<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
</li>
<li>UDP：无连接传输，数据报，<strong>8字节头部</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/29.png" alt="Untitled"></li>
</ul>
<p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/30.png" alt="Untitled"></p>
<ul>
<li>TCP和UDP都不能提供的服务：延时保证，带宽保证</li>
</ul>
<h1 id="网络层（数据平面）"><a href="#网络层（数据平面）" class="headerlink" title="网络层（数据平面）"></a>网络层（数据平面）</h1><ul>
<li><strong>数据平面：分组转发</strong>，从路由器一个输入端口移动到一个合适的输出端口</li>
<li><strong>控制平面：路由</strong>，确定从源点到目的点的路径</li>
<li>转发和路由有2种方式：传统方式 和 SDN（soft define network） 方式</li>
</ul>
<h2 id="路由器的组成"><a href="#路由器的组成" class="headerlink" title="路由器的组成"></a>路由器的组成</h2><ul>
<li>路由：运行路由选择算法协议（RIP，OSPF，BGP）生产路由表</li>
<li>转发：从输入到输出链路交换数据报，根据路由表进行分组的转发</li>
</ul>
<p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/31.png" alt="Untitled"></p>
<ul>
<li>路由器缓冲区的分组会根据优先级来进行调度转发</li>
<li>缓冲区存在的意义是为了匹配接收和发送的速率不一致问题</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/32.png" alt="Untitled"></p>
<ul>
<li>IP 数据报格式<ul>
<li>16-bit identifier，flags，fragment offset 这三个用于分片重组使用</li>
<li>upper layer：表示要交付给上层哪个协议，是TCP还是UDP</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/33.png" alt="Untitled"></li>
<li>分片和重组  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/34.png" alt="Untitled">  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/35.png" alt="Untitled"></li>
<li>IPv4地址：32位标示，对主机或者路由器的接口编址<ul>
<li><strong>一个IP地址和一个接口相关联</strong></li>
<li><strong>主机可以有多个IP地址（多张网卡就可以有多个IP），路由器至少有2个IP地址</strong></li>
<li><strong>子网Subnets</strong><ul>
<li>所有子网内IP的前缀是一样的</li>
<li>在子网范围内之需要一跳可达，无需借助路由器</li>
<li>如何判断两个IP处于同一子网内？<ul>
<li>借助子网掩码，IP和子网掩码做&amp;操作，如果一致则在同一子网</li>
</ul>
</li>
</ul>
</li>
<li><strong>IP地址分类</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/36.png" alt="Untitled"></li>
<li><strong>内网专用地址</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/37.png" alt="Untitled"></li>
<li><strong>IP编址：CIDR（Classless InterDomain Routing）无类域间路由</strong><ul>
<li>子网部分可以在任意部分</li>
<li>地址格式：a.b.c.d/x，其中x是地址中子网号的长度  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/38.png" alt="Untitled"></li>
<li><strong>转发表和转发算法</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/39.png" alt="Untitled"></li>
<li>DHCP协议（实现UDP之上，涉及广播）<ul>
<li>用户在上线时通过DHCP协议向DHCP Server自动获取IP地址，可以更新对主机在用IP地址的租用期-租期快到了，重新启动时，允许重新使用以前用过的IP地址，支持移动用户加入到该网络（短期在网）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>NAT（<strong>N</strong>etwork <strong>A</strong>ddress <strong>T</strong>ranslation）网络地址转换，完成将内网IP转化为公网的IP，完成路由<ul>
<li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备，省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界</li>
<li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li>
<li>局域网内部的设备没有明确的地址，对外是不可见的，安全</li>
</ul>
</li>
<li>IPv6地址<ul>
<li>动机：<ul>
<li>IPv4不够用</li>
<li>头部格式改变帮助加速处理和转发<ul>
<li>TTL - 1</li>
<li>头部checksum</li>
<li>分片</li>
</ul>
</li>
</ul>
</li>
<li>头部  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/40.png" alt="Untitled"></li>
<li>和IPv4的变化<ul>
<li>CheckSum被移除，加快每一段中的处理速度</li>
<li>Options：允许，但是在头部之外, 被“Next Header” 字段标示</li>
<li>ICMPv6：ICMP的新版本<ul>
<li>附加了报文类型, e.g. “Packet Too Big”</li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
</li>
<li>IPv4 到 IPv6 的过渡：双栈隧道技术<ul>
<li>隧道技术：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/41.png" alt="Untitled"></li>
<li>例子理解<ul>
<li>IPv4的海洋中各自IPv4通信没有问题</li>
<li>IPv6的岛上各自通信也没有问题</li>
<li>IPv6岛1上的主机和IPv6岛2上的主机通信需要借助隧道技术来将IPv6封装成IPv4报文通过隧道传到IPv6岛2，之后解封装，发送到目的主机</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/42.png" alt="Untitled"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/43.png" alt="Untitled"></p>
<ul>
<li>传统方式：<ul>
<li>概述：  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/44.png" alt="Untitled"></li>
<li>缺点：  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/45.png" alt="Untitled"></li>
</ul>
</li>
<li>SDN方式：  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/46.png" alt="Untitled"><ul>
<li>实现思路：  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/47.png" alt="Untitled"></li>
<li>SDN优势：  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/48.png" alt="Untitled"></li>
</ul>
</li>
<li>SDN架构<ul>
<li>控制器，也称为网络操作系统  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/49.png" alt="Untitled"></li>
<li>控制应用  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/50.png" alt="Untitled"></li>
</ul>
</li>
<li>OpenFlow 数据平面抽象<ul>
<li>流：由分组（帧）头部字段所定义</li>
<li>通用转发：简单的分组处理规则<ul>
<li>模式：将分组头部字段和流表进行匹配</li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器</li>
<li>优先权Priority：几个模式匹配了，优先采用哪个，消除歧义</li>
<li>计数器Counters：#bytes 以及#packets</li>
</ul>
</li>
</ul>
</li>
<li>OpenFlow 流表的表项结构  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/51.png" alt="Untitled"></li>
</ul>
<h1 id="网络层（控制平面）"><a href="#网络层（控制平面）" class="headerlink" title="网络层（控制平面）"></a>网络层（控制平面）</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>路由的概念：按照某种指标(传输延迟,所经过的站点数目等)找到一条<br>从源节点到目标节点的较好路径。</p>
<p>就是计算网络到网络是如何走的问题，也就是路由器之间是如何走的。</p>
<p>比如有网络拓扑如下：</p>
<p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/52.png" alt="Untitled"></p>
<p><strong>C(src，des) = 链路的代价（src，des），如C(w，z）= 5</strong></p>
<p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/53.png" alt="Untitled"></p>
<h3 id="链路状态算法-Link-State"><a href="#链路状态算法-Link-State" class="headerlink" title="链路状态算法 Link State"></a>链路状态算法 Link State</h3><ul>
<li><strong>全局：所有的路由器拥有完整的拓扑和边的代价的信息，通过广播泛洪的方式获取所有的节点信息，然后通过</strong>Dijkstra<strong>算法计算出最短路径拓扑。</strong></li>
<li>基本工作流程：<ol>
<li>发现相邻节点，获知对方的网络地址</li>
<li>测量到相邻节点的代价（延迟，开销）</li>
<li>组装成一个LS分组，描述它到相邻节点的代价情况</li>
<li>将分组通过扩散的方式发到所有的其它路由器<ol>
<li>顺序号：用于控制无穷的扩散，每个路由器都记录(源路由器,顺序号)，发现重复的或老的就不扩散<ol>
<li>问题1：循环使用问题</li>
<li>问题2：路由器崩溃后序号从0开始</li>
<li>问题3：序号出现错误</li>
</ol>
</li>
<li>解决方法：TTL，过一个路由器，TTL-1，减为0，丢掉该分组</li>
</ol>
</li>
<li>通过Dijkstra算法找出最短路径</li>
</ol>
</li>
<li>Dijkstra主要流程<ul>
<li>C(i，j) ： 从 i 节点到 j 节点链路的代价</li>
<li>D(v)：从源节点到节点 v 的当前路径代价</li>
<li>P(v)：从源节点到节点 v 的路径的前序节点</li>
<li>$N’$：当前已经知道最优路径的的节点集合(永久节点的集合)</li>
<li>临时节点(tentative node) ：还没有找到从源节点到此节点的最优路径的节点</li>
<li>永久节点：(permanent node) N’：已经找到了从源节点到此节点的最优路径的节点</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/54.png" alt="Untitled">  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/55.png" alt="Untitled">  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/56.png" alt="Untitled">  $<strong>D(v) = min(D(v),D(w) + C(w,v)) = min(7,6)=6</strong>$</li>
<li>如果链路的代价是拥塞程度，Dijkstra可能会出现链路来回震荡，高负载切换到低负载链路，之后又因为低负载变为高负载，又切换，此起彼伏的出现。</li>
<li>应用：OSPF协议，IS-IS协议</li>
</ul>
<h3 id="距离矢量算法-Distance-vector"><a href="#距离矢量算法-Distance-vector" class="headerlink" title="距离矢量算法 Distance vector"></a>距离矢量算法 Distance vector</h3><p><strong>分布式：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值，需要叠代地与邻居交换路由信息、计算路由信息。</strong></p>
<p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/57.png" alt="Untitled"></p>
<ul>
<li>迭代式的算法，定时的将该节点到达其他节点的代价交换给邻居节点（路由信息通告）。  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/58.png" alt="Untitled"><ul>
<li>该例子：J→G的路由下一跳发给谁如何确定：<ul>
<li>J的邻居是：A，I，H，K</li>
<li>所以要根据几个邻居来获取路由信息，看右下角的图可以知道：<ul>
<li>A→G代价18</li>
<li>I→G代价31</li>
<li>H→G代价6</li>
<li>K→G代价31</li>
</ul>
</li>
<li>J到邻居的代价分别是：8，10，12，6</li>
<li>step2和step3相加后发现下一跳应该发送给H</li>
</ul>
</li>
</ul>
</li>
<li>递归方程  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/59.png" alt="Untitled"></li>
<li>DV算法的特点：<ul>
<li>好消息传递的快  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/60.png" alt="Untitled"></li>
<li>坏消息传递的慢：B是直连A的，B转发给A时，发现挂掉了，其实后面的CDE都是借助B来转发给A的，但是在A挂掉后这个坏消息还没有传递给CDE，CDE此时仍然认为自己有能力转发消息到A，所以坏消息传递的慢（解决方法：水平分裂，但仍不能解决环状拓扑）  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/61.png" alt="Untitled"></li>
</ul>
</li>
</ul>
<h3 id="LS和DV的比较"><a href="#LS和DV的比较" class="headerlink" title="LS和DV的比较"></a>LS和DV的比较</h3><p><img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/62.png" alt="Untitled"></p>
<h2 id="ISP内部自治的路由选择协议（IGP协议）"><a href="#ISP内部自治的路由选择协议（IGP协议）" class="headerlink" title="ISP内部自治的路由选择协议（IGP协议）"></a>ISP内部自治的路由选择协议（IGP协议）</h2><h3 id="RIP：DV算法的应用"><a href="#RIP：DV算法的应用" class="headerlink" title="RIP：DV算法的应用"></a>RIP：DV算法的应用</h3><ul>
<li>RIP通告：<ul>
<li>在邻居之间<strong>每30s</strong>交换通告报文<ul>
<li>定期，而且在改变路由的时候发通告报文</li>
<li>在对方的请求下可以发送通告报文</li>
</ul>
</li>
<li>每个通告：最多25个子网，路由跳数最大16（此时认为不可达）</li>
</ul>
</li>
<li>RIP: 链路失效和恢复：如果180秒没有收到通告信息，认为邻居或者链路失效<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告 (如果路由变化的话)</li>
<li>链路失效快速地在整网中传输</li>
<li>使用毒性逆转（poison reverse）阻止ping-pong回路(不可达的距离：跳数无限 = 16 段)</li>
</ul>
</li>
<li>RIP进程处理  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/63.png" alt="Untitled"></li>
</ul>
<h3 id="OSPF：LS算法的应用"><a href="#OSPF：LS算法的应用" class="headerlink" title="OSPF：LS算法的应用"></a>OSPF：LS算法的应用</h3><ul>
<li>Open Shortest Path First：<ul>
<li>使用LS算法， LS 分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑、代价在每一个节点中都保持</li>
<li>路由计算采用Dijkstra算法</li>
</ul>
</li>
<li>高级特性（RIP所没有的）<ul>
<li>安全: 所有的OSPF报文都是经过认证的 (防止恶意的攻击)</li>
<li>允许有多个代价相同的路径存在 (在RIP协议中只有一个)</li>
<li>对于每一个链路，对于不同的TOS有多重代价矩阵<ul>
<li>例如：卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置的比较高</li>
<li>支持按照不同的代价计算最优路径，如：按照时间和延迟分别计算最优路径</li>
</ul>
</li>
<li>对单播和多播的集成支持：<ul>
<li>Multicast OSPF (MOSPF) 使用相同的拓扑数据库，就像在OSPF中一样</li>
</ul>
</li>
<li>在大型网络中支持<strong>层次性OSPF</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/64.png" alt="Untitled"></li>
</ul>
</li>
</ul>
<h2 id="ISP之间路由协议：BGP协议"><a href="#ISP之间路由协议：BGP协议" class="headerlink" title="ISP之间路由协议：BGP协议"></a>ISP之间路由协议：BGP协议</h2><h3 id="平面路由的问题"><a href="#平面路由的问题" class="headerlink" title="平面路由的问题"></a>平面路由的问题</h3><ul>
<li>在规模大的网络中带来的传输，存储，计算代价很大<ul>
<li>DV：距离矢量很大，不能收敛</li>
<li>LS：数量大的泛洪传输，存储，然后通过Dijkstra计算复杂</li>
</ul>
</li>
<li>管理问题：<ul>
<li>不同网络的管理方式不同</li>
<li>无法隐藏自己网络的特点</li>
<li>各个网络互联的问题</li>
</ul>
</li>
</ul>
<h3 id="层次路由的引入"><a href="#层次路由的引入" class="headerlink" title="层次路由的引入"></a>层次路由的引入</h3><ul>
<li>将互联网分成一个个的AS（autonomous systems）自治系统，用AS Number标识</li>
<li>不同的AS内部可以运行不同的 IGP（OSPF or RIP）协议，通过边界网关路由器和其他AS互联</li>
<li>优点：<ul>
<li>解决了规模问题，可扩展性强</li>
<li>解决了管理问题，每个AS内部各自选择协议，无需向外透露</li>
</ul>
</li>
<li>BGP 提供给每个AS以以下方法：<ul>
<li>eBGP: 从相邻的ASes那里获得子网可达信息</li>
<li>iBGP: 将获得的子网可达信息传遍到AS内部的所有路由器</li>
<li>根据子网可达信息和<strong>策略</strong>来决定到达子网的“好”路径</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/65.png" alt="Untitled"></li>
<li>BGP基础<ul>
<li>BGP 会话: 2个BGP路由器(“peers”)在一个半永久的TCP连接上交换BGP报文：<ul>
<li>通告向不同目标子网前缀的“路径”（BGP是一个“<strong>路径矢量</strong>”协议），注意是会存储路径的</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/66.png" alt="Untitled"></li>
<li>BGP通告  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/67.png" alt="Untitled"></li>
</ul>
</li>
<li>BGP报文：使用TCP协议交换BGP报文<ul>
<li>open：打开tcp连接，认证发送方</li>
<li>update：通告新路径 or 撤销原路径</li>
<li>keepalive：在没有更新时保持连接，也用于对open请求确认</li>
<li>notification：报告以前的消息错误，也用来关闭连接</li>
</ul>
</li>
<li>热土豆路由：不操心AS之间的代价，只考虑内部选择最小的路径  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/68.png" alt="Untitled"></li>
<li>路径通告执行策略  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/69.png" alt="Untitled"></li>
</ul>
<h1 id="数据链路层和局域网"><a href="#数据链路层和局域网" class="headerlink" title="数据链路层和局域网"></a>数据链路层和局域网</h1><p>网络层解决的是一个网络如何到达另外一个网络的问题，在一个子网内部如何从一个节点（主机or路由器）到达另外一个节点，数据链路层+物理层粉墨登场，提供<strong>”点到点“的传输</strong>功能。</p>
<h3 id="网络节点互联的方式："><a href="#网络节点互联的方式：" class="headerlink" title="网络节点互联的方式："></a>网络节点互联的方式：</h3><ul>
<li>点到点的连接：一般用于WAN</li>
<li>多点连接：通过共享型介质，比如交换机等。一般用于LAN</li>
<li>WAN（广域网）：<ul>
<li>带宽大，距离远，带宽延迟积大，如果采用多点连接出现冲突，代价大，一般都是远距离拉专线专用。</li>
</ul>
</li>
<li>LAN（局域网）<ul>
<li>连接点方便，直接连接到共享型介质（路由器，交换机等）</li>
<li>WLAN：无线局域网</li>
<li>VLAN：虚拟局域网，即在物理上不聚集在一起，但仍归属同一个局域网</li>
</ul>
</li>
</ul>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><ul>
<li>节点：主机，路由器，交换机等</li>
<li>沿着通信路径，连接各相邻节点通信信道的是链路<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享型链路</li>
</ul>
</li>
<li>协议单元：帧frame</li>
<li>负责从一个节点将帧中的数据包发送到相邻节点（一般是子网内的两个节点）</li>
<li>链路层在哪里实现？<ul>
<li>在主机的<strong>适配器</strong>上实现链路层和相应物理层的功能<ul>
<li>以太网卡，802.11网卡</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/70.png" alt="Untitled"></li>
</ul>
</li>
<li>差错检测<ul>
<li>EDC = 差错检测和纠正位（冗余位），EDC越长检测纠正效果越好</li>
<li>D = 数据由差错检测保护，可以包含头部字段  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/71.png" alt="Untitled"></li>
<li>单bit奇偶校验：检测单bit错误<ul>
<li>奇校验：确保传输的所有数据中的1的个为奇数，d+1位后1的个数是奇数<table>
<thead>
<tr>
<th>原信息</th>
<th>奇校验传输信息</th>
</tr>
</thead>
<tbody><tr>
<td>11011</td>
<td>110111</td>
</tr>
<tr>
<td>01101</td>
<td>011010</td>
</tr>
</tbody></table>
</li>
<li>偶校验：确保传输的所有数据中的1的个为偶数，d+1位后1的个数是偶数<table>
<thead>
<tr>
<th>原信息</th>
<th>偶校验传输信息</th>
</tr>
</thead>
<tbody><tr>
<td>11011</td>
<td>110110</td>
</tr>
<tr>
<td>01101</td>
<td>011011</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>2维奇偶校验：检测和纠正单bit错误  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/72.png" alt="Untitled"></li>
<li>CRC循环冗余校验  选择 r 位CRC附加位R，使得&lt;D,R&gt;正好被G整除。接收方知道G，如果除后余数非0，则出错。可以检测出少于r+1位的错误。  广泛应用于：以太网、802.11 WiFi、ATM  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/73.png" alt="Untitled"><ul>
<li>D：数据比特</li>
<li>G：<strong>双方协商的 r+1 位多项式</strong>（r次方）<ul>
<li>比如1011 即：$1<em>x^3 + 0</em>x^2 + 1<em>x^1  + 1</em>x^0 = x^3 + x + 1$</li>
</ul>
</li>
<li>附加位的CRC是 r 位，是需要求取的。</li>
<li>求取例子：  D = 101110  G = 1001  由于G是4位，则R需要3位，D左移3位，补0，然后开始模2运算，将余数附在D后面传输给接收方，接收方验证有余数否，无则正确接受，否则丢弃  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/74.png" alt="Untitled"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><ul>
<li>两种类型的链路<ul>
<li>点对点：<ul>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li>广播：<ul>
<li>传统以太网</li>
<li>802.11无线局域网</li>
</ul>
</li>
</ul>
</li>
<li>多站点同时传送会出现信道使用冲突</li>
<li>MAC（媒体访问介质）协议分类<ul>
<li>信道划分：时分，频分，码分，分配片给每个节点使用</li>
<li>随机访问：信道不划分，允许冲突，冲突后恢复</li>
<li>依次轮流：节点依次轮流，但是有很多数据传输的节点拥有较长时间的信道使用权</li>
</ul>
</li>
<li>目前大多使用随机访问MAC，面临的问题：<ul>
<li>如何检测冲突</li>
<li>如何在冲突后恢复</li>
</ul>
</li>
<li>引出CSMA，CSMA/CD，CSMA/CA 协议<ul>
<li>CSMA 载波侦听多路访问：发送前侦听信道是否空闲，闲则发送，否则推迟发送<ul>
<li>冲突发生，产生原因：局部侦听，无法判断传播延迟大的其他节点有使用信道，之后就会出现冲突，如图红黄区域则是无效传输。即传播延迟决定了冲突概率，越大则越大。  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/75.png" alt="Untitled"></li>
</ul>
</li>
<li><strong>CSMA/CD  载波侦听多路访问/冲突检测，传输前侦听，一边传输一遍监听，如果传输过程中发现冲突，则停止传输，减少对信道的浪费</strong><ul>
<li>一般只适用于<strong>有线</strong>局域网中容易实现</li>
</ul>
  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/76.png" alt="Untitled"><ul>
<li>CSMA/CD 算法过程：<ul>
<li>发送前：<ul>
<li>如果闲，则发送</li>
<li>如果忙，则推迟到闲再发送</li>
</ul>
</li>
<li>发送中：<ul>
<li>没有冲突，则成功</li>
<li>检测到冲突，则终止传输，之后尝试重发。</li>
<li>发送方适配器发现冲突后除了终止传输同时会发送一个Jam信号，<strong>强化冲突</strong>，让所有的站点都知道发生了冲突</li>
<li>放弃后进入指数退避算法状态，在第m次失败后，适配器随机选择一个{0，1，2，…… ， 2^m-1} 中选择一个K，等待K*512位时转到发送状态</li>
</ul>
</li>
</ul>
</li>
<li>指数退避的自适应算法：<ul>
<li>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发<ul>
<li>高负载：重传窗口时间大，减少冲突，但等待时间长</li>
<li>低负载：使得各站点等待时间少，但冲突概率大</li>
</ul>
</li>
<li>过程：窗口随着碰撞次数增大而增大，从而多方选择的范围变大，碰撞概率减小，增大发送成的概率。<ul>
<li>首次碰撞：在{0，1}选择K；延迟K*512位时</li>
<li>第2次碰撞：在{0，1，2，3}选择K</li>
<li>第10次碰撞：在{0，1，2，3，……，1023}选择K</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>CSMA/CA：载波侦听多路访问/冲突避免，一般用于WLAN无限局域网中</strong><ul>
<li>不选用CD的原因：<ul>
<li>传输介质不同，无线的介质传输随着距离信号的删减非常严重，无法检测冲突</li>
<li>开放的空间冲突干扰太大，而在有线介质中不会和其他正在传输的节点发生冲突</li>
</ul>
</li>
<li>发送前监听，如果忙则随机选择一个数值X，之后定时检测，每当检测到信道空闲时则减1，直到减为0时发送，同时需要ACK来避免冲突</li>
<li><strong>隐藏终端问题，意味着不冲突不一定成功</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/77.png" alt="Untitled">  如图A和C互相无感知，当A和C都要向B发送时则会出现冲突</li>
<li><strong>暴露终端问题，意味着冲突不一定不成功</strong>  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/78.png" alt="Untitled">  如图，B可以感知到C向D传，但是B向A传，虽然冲突，但是互不影响</li>
<li><strong>但是在有线LAN中，基本可以认为不冲突就是成功，条件：帧的传输时间累计要≥2*t，其中 t 为最远的2个站点的传播时延，原因如图：</strong>  如果在B点之前的 t’ 时刻，此时Sender发送的数据还没有到达Accept，那Accept也要发送数据，测试侦听一下发现信道可用，但是刚发就出现了碰撞，然后这个碰撞信息又需要 t 时间才能传送给 Sender，如果Sender之前黄色区域时认定发送成功，则一定收不到该冲突信息，实质时发送失败。  <img src="/2022/03/20/%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/79.png" alt="Untitled"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="LANS"><a href="#LANS" class="headerlink" title="LANS"></a>LANS</h3><ul>
<li>MAC 地址：用于使帧从一个网卡传递到与其物理连接的另一个网卡(在同一个物理网络中)，48bit，如：1A-2F-BB-76-09-AD，每位用16进制表示。</li>
<li>IP地址和MAC地址分离的原因：<ul>
<li>IP地址和MAC地址的作用不同<ul>
<li>IP地址是分层的<ul>
<li>一个子网所有站点网络号一致，路由聚集，减少路由表</li>
<li>需要一个网络中的站点地址网络号一致，如果捆绑需要定制网卡非常麻烦</li>
<li>希望网络层地址是配置的；IP地址完成网络到网络的交付</li>
</ul>
</li>
<li>mac地址是一个平面的<ul>
<li>网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一的标示，用于区分一个网络内部不同的网卡即可</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付</li>
</ul>
</li>
</ul>
</li>
<li>分离的好处：<ul>
<li>网卡坏了，ip不变，可以捆绑到另外一个网卡的mac上</li>
<li>物理网络还可以除IP之外支持其他网络层协议，链路协议为任意上层网络协议</li>
</ul>
</li>
<li>捆绑的问题：<ul>
<li>如果仅仅使用IP地址，不用mac地址，那么它仅支持IP协议</li>
<li>每次上电都要重新写入网卡 IP地址；</li>
<li>另外一个选择就是不使用任何地址；<strong>不用MAC地址，则每到来一个帧都要上传到IP层次</strong>，由它判断是不是需要接受，干扰一次</li>
</ul>
</li>
</ul>
</li>
<li>交换机：存储MAC地址，用于子网内转发消息。同时解决了CSMA/CD中在信道高负载时利用率低的问题，因为都是主机专用的接入交换机，没有其它主机抢用。</li>
</ul>
<h1 id="一个Web请求的生命流程（用于回顾整个协议栈）"><a href="#一个Web请求的生命流程（用于回顾整个协议栈）" class="headerlink" title="一个Web请求的生命流程（用于回顾整个协议栈）"></a>一个Web请求的生命流程（用于回顾整个协议栈）</h1><ul>
<li>笔记本需要一个IP地址，采用DHCP协议进行分配<ul>
<li>DHCP请求被封装在UDP中，封装在IP数据报，封装在802.3以太网帧</li>
<li>以太网的帧在LAN上广播（MAC地址：FF-FF-FF-FF-FF-FF）被运行中的DHCP服务器接收，之后解封装帧，解封装IP，解封装UDP获取到DHCP请求。</li>
<li>DHCP服务器生成DHCP ACK，包括客户端IP地址，第一跳路由器IP地址和DNS名字服务器地址。</li>
<li>DHCP服务器封装成帧转发到交换机（交换机已经自学习了请求发来时的路径，即源mac地址），交换机负责转发给client，client接收到后解封装获取IP，DNS的IP，第一跳的路由器的IP</li>
</ul>
</li>
<li>ARP查询广播：发生在DNS之前，HTTP之前<ul>
<li>在发送HTTP请求之前，需要直到 <a href="http://www.google.com/">www.google.com</a> 的IP地址，需要DNS</li>
<li>DNS查询被创建，封装在UDP段中，封装在IP数据报中，封装在以太网的帧中，将帧传递给路由器，但是需要直到路由器的接口的mac地址，则需要ARP协议通过IP获取其mac地址</li>
<li>ARP查询广播，被路由器接收，路由器用ARP应答，给出其mac地址</li>
<li>现在直到第一跳路由器的mac地址，则可以发DNS查询了</li>
</ul>
</li>
<li>DNS请求<ul>
<li>DNS请求发送到DNS服务器（可能存在迭代 or 递归的获取）</li>
<li>DNS服务器给出应答包：包含了<a href="http://www.google.com/">www.google.com</a> 的IP地址</li>
</ul>
</li>
<li>HTTP请求<ul>
<li>为了发送HTTP请求，client需要创建一个到达web服务器的TCP Socket</li>
<li>TCP SYN段（第1次握手）发送到web服务器</li>
<li>web服务器用tcp  SYN + ACK（第2次握手）发送给client</li>
<li>TCP连接建立</li>
<li>HTTP请求的数据 + 第3次握手 合并一起发送到web服务器</li>
<li>web服务器相应HTTP请求，返回HTTP应答报文经协议栈路由回client</li>
<li>client进行解析渲染完成</li>
</ul>
</li>
</ul>
<h1 id="附录：协议流模拟动画网站"><a href="#附录：协议流模拟动画网站" class="headerlink" title="附录：协议流模拟动画网站"></a>附录：协议流模拟动画网站</h1><p><a href="https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/index.html">Student Resources</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>基础计算机网络</tag>
      </tags>
  </entry>
</search>
