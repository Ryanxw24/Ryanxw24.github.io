<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ryanxw&#39;s blog</title>
  
  <subtitle>流水不争先，争滔滔不绝</subtitle>
  <link href="https://ryanxw24.github.io/atom.xml" rel="self"/>
  
  <link href="https://ryanxw24.github.io/"/>
  <updated>2022-03-05T18:48:23.621Z</updated>
  <id>https://ryanxw24.github.io/</id>
  
  <author>
    <name>ryanxw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFPRT</title>
    <link href="https://ryanxw24.github.io/2021/10/06/BFPRT/"/>
    <id>https://ryanxw24.github.io/2021/10/06/BFPRT/</id>
    <published>2021-10-05T18:40:00.000Z</published>
    <updated>2022-03-05T18:48:23.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFPRT"><a href="#BFPRT" class="headerlink" title="BFPRT"></a>BFPRT</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>用于解决TopK问题。</p><ul><li>TopK问题：从长度为N的<strong>无序数组</strong>中找出前K大的数</li><li>BFPRT算法：1973年，由5位科学家 Blum 、 Floyd 、 Pratt 、 Rivest 、 Tarjan发表了一篇 <a href="https://people.csail.mit.edu/rivest/BlumFloydPrattRivestTarjan-TimeBoundsForSelection.pdf">“Time bounds for selection”</a> 的论文，讲述了如何选取第K大的元素，也称为”Median of medians”，即中位数的中位数算法。<strong>该算法的时间复杂度可以严格收敛到O(n)级别。</strong></li></ul><h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><p>假设现在存在一个函数 GetKthNum(arr[], k)  可以获取到第k大的数，这个函数中要做哪些事情：</p><ul><li>数组的长度为n，则每5个划分为1组，不够5个元素的单独成组，一共由n/5组。时间复杂度：O(1)</li><li>每5个数在组内排序，组与组之间无序。时间复杂度：O(1) * n / 5 = O(n)</li><li>将排好序的每组中的<strong>上中位数</strong>取出来单独成组MediansArr，该组的长度为n/5。然后递归的调用GetKthNum(MediansArr, n/10) 函数，目的是为了获取到中位数数组的中位数Pivot。<ul><li>上中位数：（1，2，3，4，5）取3，（1，2，3，4）取2</li><li>为什么是n/10，因为数组的长度是n/5，其中位数的一定是处于n/10的位置。</li><li>时间复杂度：自己调用自己，T(n/5)</li></ul></li><li>此时用Pivot去进行快排中提到的 partition 过程，时间复杂度：O(n)<ul><li>&lt; Pivot 的数放在左边</li><li>= Pivot 的数放在中间</li><li><blockquote><p>Pivot 的数放在右边</p></blockquote></li></ul>  将返回的等于区域数组pArr，判断是否命中K<ul><li>pArr[0] == K，停止</li><li>pArr[0] &gt; K，左半部分进行递归</li><li>pArr[0] &lt; K，右半部分进行递归</li></ul></li><li>上面的递归过程每次都可以严格的淘汰掉至少n*3/10的数据量，看图很容易明白：  <img src="/2021/10/06/BFPRT/Untitled.png" alt="Untitled">  一共有n/5组，中位数数组的中位数值为Pivot，在该数组中有n/10个数的值比Pivot小，这些数字在各自的小数组中又是中位数，则表示这些组每组存在3/5个数比Pivot小，所以在原数组中就至少有<strong>n*3/10</strong>的数据量比Pivot小。也就是最多<strong>n*7/10</strong>有比Pivot大，确定了递归规模。</li><li>整体时间复杂度T(n) = T(n/5) + T(n*7/10) + O(n)，可以收敛到O(n)，证明（<a href="https://zhuanlan.zhihu.com/p/291206708">参考链接</a>）如下：  <img src="/2021/10/06/BFPRT/Untitled1.png" alt="Untitled"></li></ul><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><h2 id="3-1-Partition过程回顾"><a href="#3-1-Partition过程回顾" class="headerlink" title="3.1 Partition过程回顾"></a>3.1 Partition过程回顾</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; equals;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> m = l;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[m] == pivot) &#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[more--], arr[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++less], arr[m++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    equals.<span class="built_in">push_back</span>(less + <span class="number">1</span>);</span><br><span class="line">    equals.<span class="built_in">push_back</span>(more);</span><br><span class="line">    <span class="keyword">return</span> equals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-BFPRT实现"><a href="#3-2-BFPRT实现" class="headerlink" title="3.2 BFPRT实现"></a>3.2 BFPRT实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">get_min_kth_nums_by_bfprt</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; len)   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> kth_num_val = <span class="built_in">get_indexth_num_of_arr</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> ik = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= kth_num_val)</span><br><span class="line">        &#123;</span><br><span class="line">            res[ik++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_indexth_num_of_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> arr[l];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">get_median_of_medians_arr</span>(arr, l, r);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;------------p------------&quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span>* part_res = <span class="built_in">partition</span>(arr, l, r, p);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;part_res [0] = &quot; &lt;&lt; part_res[0] &lt;&lt; &quot;, part_res[1] = &quot; &lt;&lt; part_res[1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= part_res[<span class="number">0</span>] &amp;&amp; index &lt;= part_res[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index &lt; part_res[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_indexth_num_of_arr</span>(arr, l, part_res[<span class="number">0</span>] - <span class="number">1</span>, index);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_indexth_num_of_arr</span>(arr, part_res[<span class="number">1</span>] + <span class="number">1</span>, r, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; p)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[++less], arr[i++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; p)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[more--], arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *part = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    part[<span class="number">0</span>] = less + <span class="number">1</span>;</span><br><span class="line">    part[<span class="number">1</span>] = more;</span><br><span class="line">    <span class="keyword">return</span> part;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_median_of_medians_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> offset = count % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> medians_arr_len = count / <span class="number">5</span> + offset;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;medians_arr_len: &quot; &lt;&lt; medians_arr_len &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> medians_arr[medians_arr_len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; medians_arr_len; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> part_begin = l + <span class="number">5</span> * i;</span><br><span class="line">        <span class="keyword">int</span> part_end = <span class="built_in">min</span>((part_begin + <span class="number">4</span>), r);</span><br><span class="line">        medians_arr[i] = <span class="built_in">get_median</span>(arr, part_begin, part_end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;medians_arr has: &quot;;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt;  medians_arr_len; ++i)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; medians_arr[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_indexth_num_of_arr</span>(medians_arr, <span class="number">0</span>, medians_arr_len - <span class="number">1</span>, medians_arr_len / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_median</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. insert sort </span></span><br><span class="line">    <span class="built_in">insert_sort</span>(arr, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 2. return arr[mid]</span></span><br><span class="line">    <span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; l; --j)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BFPRT&quot;&gt;&lt;a href=&quot;#BFPRT&quot; class=&quot;headerlink&quot; title=&quot;BFPRT&quot;&gt;&lt;/a&gt;BFPRT&lt;/h1&gt;&lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念</summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-TopK" scheme="https://ryanxw24.github.io/tags/algo-TopK/"/>
    
  </entry>
  
  <entry>
    <title>Manacher</title>
    <link href="https://ryanxw24.github.io/2021/10/03/Manacher/"/>
    <id>https://ryanxw24.github.io/2021/10/03/Manacher/</id>
    <published>2021-10-03T10:55:38.000Z</published>
    <updated>2022-03-04T11:00:08.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>用于求取字符串中最大的回文子串，需要考虑的是奇回文 or 偶回文</p><ul><li>奇回文：123a321，其中字符a所处的位置为对称轴，实轴</li><li>偶回文：1221，其中两个2中间的位置为对称轴，虚轴</li></ul><p>所以在判断回文串时需要先处理一下字符串本身，让虚轴显示出来，比如加入特殊字符”#”来保证虚轴可以看到。</p><ul><li>不用担心特殊字符和字符串中的原字符发生冲突，因为是对称的，虚轴只会和虚轴相比较。</li><li>处理过后的样子：<ul><li>奇回文：#1#2#3#a#3#2#1#</li><li>偶回文：#1#2#2#1#</li></ul></li></ul><h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><p>假设字符串的长度是N，处理成特殊字符后每个位置都开始向两边扩，比较字符，记录好最大的回文长度就ok，每次有更大的就更新。</p><ul><li>时间复杂度O(N^2)</li></ul><h2 id="2-2-manancher解法"><a href="#2-2-manancher解法" class="headerlink" title="2.2 manancher解法"></a>2.2 manancher解法</h2><p>解决掉在暴力解法中一些地方无需尝试扩，比较，直接向后跳即可。</p><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><p>要先熟悉几个概念</p><ul><li><strong>回文半径</strong></li><li><strong>最右回文边界R</strong>（R一定停在特殊字符上，因为只有实际字符才存在不同，扩不动的情况）</li><li><strong>最有回文边界的中心C</strong>（只记录第一次【即最早】冲到R时候的C的位置，此时为最长情况）</li></ul><h3 id="几种拓扑图（核心）"><a href="#几种拓扑图（核心）" class="headerlink" title="几种拓扑图（核心）"></a>几种拓扑图（核心）</h3><p>初始化遍历字符串的下标 Index = 0</p><ol><li>最右回文边界 R 在 Index 的左边，即 R &lt; Index <img src="/2021/10/03/Manacher/Untitled.png" alt="Untitled"> <strong>这种情况下没有优化空间，只能暴力匹配</strong></li><li>最右回文边界 R 在 Index 的右边，即 R &gt; Index<ol><li>Index 位置的对称点 <strong>Index’</strong> 的回文范围就在 <strong>(L，R)</strong> 内 <img src="/2021/10/03/Manacher/Untitled1.png" alt="Untitled"> <img src="/2021/10/03/Manacher/Untitled2.png" alt="Untitled"> 由图可以知道在对称点 <strong>Index’</strong> 的位置已经扩到了 <strong>X ≠ Y</strong> 处不能再向两边扩了。而目前Center所处的位置 <strong>C</strong> 所扩到最大的边界时<strong>（L，R）</strong>，所以 P == Y, Q == X。而 X ≠ Y，则 P  ≠ Q</li><li>Index位置的对称点 <strong>Index’</strong> 的回文范围只有部分在 <strong>(L，R)</strong> 内 <img src="/2021/10/03/Manacher/Untitled3.png" alt="Untitled"> <img src="/2021/10/03/Manacher/Untitled4.png" alt="Untitled"> 此时Index能扩充的范围就是（Index，R）。原因：<ul><li>由图可知目前 Center 所处的位置 <strong>C</strong> 所扩到最大的边界时<strong>（L，R）</strong>，所以 P ≠ Q。</li><li>而P在（i’L，i’R）这个当时以 <strong>Index’</strong> 为中心的回文串中，则一定有一个 X 和 P 关于<strong>Index’</strong> 对称，即 P == X</li><li>X 又在以 C 为中心的回文串（L，R）中，则必存在一个 Y 和 X 关于 C 对称，即X == Y</li><li>因为 P == X，X == Y，所以 P == Y，而 P ≠ Q，则Y≠Q，所以最多扩到<strong>（Index，R）</strong></li></ul> <strong>为什么（Index，R）就一定是回文呢？</strong><ul><li>因为关于C对称</li></ul></li><li>Index位置的对称点 <strong>Index’</strong> 的回文范围 (i’L，i’R) 中的 <strong>i’L</strong> 刚好和 (L，R) 的<strong>L重合</strong> <img src="/2021/10/03/Manacher/Untitled5.png" alt="Untitled"> <img src="/2021/10/03/Manacher/Untitled6.png" alt="Untitled"> 由图可以知道 ：<ul><li>X == Y</li><li>W ≠ Y，则 W ≠ X</li><li>W ≠ Z</li><li>但是无法确认Z是否等于X，则只能暴力扩展去判断</li></ul></li></ol></li></ol><h3 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h3><ul><li>case1：i 在 R 右面，暴力扩，i增长，时间复杂度O(n)</li><li>case2：（i’L，i’R）在L内，不用扩，O(1)</li><li>case3：（i’L，i’R）部分在L内，即 i’L &lt; L &lt; i’R &lt; R，不用扩，O(1)</li><li>case4： i’L  == L，重合，i增长， O(n)</li></ul><p>可见只有case1 和case4 需要扩，字符串长度为n，则为O(n)</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 慎用，string累加时在处理拷贝内存时耗时很大</span></span><br><span class="line"><span class="function">string <span class="title">manacher_string</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        res = res + s[i] + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">manacher_string_2</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    string res;</span><br><span class="line">    res.<span class="built_in">resize</span>(len);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        res[i] = (i&amp;<span class="number">1</span>)==<span class="number">0</span> ? <span class="string">&#x27;#&#x27;</span> : s[idx++];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max_len_of_sub_str</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string manacher_str = <span class="built_in">manacher_string</span>(s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;manacher_str: &quot;</span> &lt;&lt; manacher_str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> manacher_str_len = manacher_str.<span class="built_in">length</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;manacher_str_len: &quot;</span> &lt;&lt; manacher_str_len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> pArr[manacher_str_len];  <span class="comment">// 回文数组，记录该位置的回文子串R是多大</span></span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_range = INT_MIN;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pArr[i] = R &gt; i ? min(pArr[2*C - i], R - i) : 1;</span></span><br><span class="line"><span class="comment">     * 该行对case1 case2 case3进行了整合, 确定了起码的回文半径</span></span><br><span class="line"><span class="comment">     * 分析case1时，i 在 R 的右边，则R &gt; i 不成立，pArr[i] = 1,则: </span></span><br><span class="line"><span class="comment">     *      (i+1 &lt; len) &amp;&amp; (i-1 &gt; -1) 条件成立，进入while向右扩</span></span><br><span class="line"><span class="comment">     * 分析case2 和 case3时，知道扩不动，时间复杂度O(1)，然后再尝试扩一下，时间复杂度也是O(1)</span></span><br><span class="line"><span class="comment">     *      取i位置对称点i&#x27;的最大回文半径pArr[2*C-i] 和[i, R]这段的最小值为pArr[i]</span></span><br><span class="line"><span class="comment">     *      进入while第1下就break，因为明确的知道 i+pArr[i] 处字符一定不等于 i-pArr[i]处字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manacher_str_len; ++i)&#123;</span><br><span class="line">        pArr[i] = R &gt; i ? <span class="built_in">min</span>(pArr[<span class="number">2</span>*C - i], R - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + pArr[i] &lt; manacher_str_len &amp;&amp; i - pArr[i] &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (manacher_str[i + pArr[i]] == manacher_str[i - pArr[i]])&#123;</span><br><span class="line">                pArr[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + pArr[i] &gt; **R)&#123;</span><br><span class="line">            R = i + pArr[i];    <span class="comment">// R是最大回文子串的长度，不是字符串的下标</span></span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        max_range = <span class="built_in">max</span>(max_range, pArr[i]); <span class="comment">// 记录一个最大的回文长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_range - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Manacher&quot;&gt;&lt;a href=&quot;#Manacher&quot; class=&quot;headerlink&quot; title=&quot;Manacher&quot;&gt;&lt;/a&gt;Manacher&lt;/h1&gt;&lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-String" scheme="https://ryanxw24.github.io/tags/algo-String/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="https://ryanxw24.github.io/2021/09/25/KMP/"/>
    <id>https://ryanxw24.github.io/2021/09/25/KMP/</id>
    <published>2021-09-25T12:35:04.000Z</published>
    <updated>2022-03-01T11:42:32.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>KMP算法的用处是为了加快<strong>子串match_str</strong>在<strong>母串orign_str</strong>中匹配查找的过程，如果匹配到则返回<strong>match_str</strong>在<strong>orign_str</strong>中的下标位置，如果没有则返回-1。</p><ul><li>如果假设母串的长度是<strong>N</strong>，子串的长度是<strong>M</strong>，则可以看出时间复杂度的差距之大：<ul><li>暴力解法：O(N*M)</li><li>KMP解法：O(N)</li></ul></li></ul><h1 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h1><p>既然想知道KMP算法优化了哪里，首先要知道常规的暴力解法慢在哪里，这样才能搞明白为什么KMP真正的进行性能提升。</p><p>假设现在有<strong>母串orign_str</strong>和<strong>子串match_str</strong></p><p><strong>orign_str  = “1234abc1234defk1234abc1234xyz789”</strong></p><p><strong>match_str= “1234abc1234xyz”</strong></p><h2 id="2-1-暴力解法"><a href="#2-1-暴力解法" class="headerlink" title="2.1 暴力解法"></a>2.1 暴力解法</h2><p>所谓暴力匹配就是从左到右一个一个字符的匹配，相同就都向后跳；一旦不同，子串从头开始和母串上一次的下一个字符开始匹配重复之前的过程直到结束。</p><p><strong>时间复杂度：O(M*N)</strong></p><p>上述的例子：</p><ul><li>开始 origin_str[i++] 和 match_str[j++] 进行比较，直到字符d≠x停止</li><li>接着 origin_str[1] 和 match_str[0] 再进行比较，不相等</li><li>接着 match_str[2] 和  match_str[0] 再进行比较，不相等</li><li>…..</li><li>match_str[7] 和 match_str[0] 相等，直到字符d≠a停止</li><li>接着match_str[11] = ‘d’ 接着和 match_str[0] 比较，不相等</li><li>接着match_str[12] = ‘e’ 接着和 match_str[0] 比较，不相等</li><li>…..</li><li>match_str[15] 和 match_str[0] 相等，直到子串匹配完成，返回母串下标idx = 15</li></ul><p><strong>根据上述的简易流程可以明显看出冗余许多无效匹配，这正是KMP进行优化的地方。</strong></p><h2 id="2-2-KMP解法"><a href="#2-2-KMP解法" class="headerlink" title="2.2 KMP解法"></a>2.2 KMP解法</h2><h3 id="2-2-1-基础知识：字符串的最大前缀，最大后缀"><a href="#2-2-1-基础知识：字符串的最大前缀，最大后缀" class="headerlink" title="2.2.1 基础知识：字符串的最大前缀，最大后缀"></a>2.2.1 基础知识：字符串的最大前缀，最大后缀</h3><ul><li>最大前缀：不包含最后一个字符</li><li>最大后缀：不包含第一个字符</li></ul><p>例子：str = “123b”，对于b这字符的最大前缀是“12”，最大后缀是“23”</p><h3 id="2-2-2-next数组：用于KMP优化的核心点"><a href="#2-2-2-next数组：用于KMP优化的核心点" class="headerlink" title="2.2.2 next数组：用于KMP优化的核心点"></a>2.2.2 <strong>next数组</strong>：用于KMP优化的核心点</h3><ul><li>定义：是根据子串建立的数组，表达的是最大前缀和最大后缀二者相匹配的长度</li><li>人为规定：<ul><li>next[0] = -1</li><li>next[1] = 0</li></ul></li></ul><p>例子：字符串str1 = “aaaab”，则next[5] = {-1, 0, 1, 2, 3}</p><h3 id="2-2-3-KMP是如何加速了匹配流程的呢？"><a href="#2-2-3-KMP是如何加速了匹配流程的呢？" class="headerlink" title="2.2.3 KMP是如何加速了匹配流程的呢？"></a>2.2.3 <strong>KMP是如何加速了匹配流程的呢？</strong></h3><p>继续使用之前的例子：</p><p><strong>orign_str  = “1234abc1234defk1234abc1234xyz789”，指针p1</strong></p><p><strong>match_str= “1234abc1234xyz”，指针p2</strong></p><ul><li>当第一次匹配到 d ≠ x 时，需要做下面的事情：<ul><li>根据 match_str 的 next 数组 x 字符所处下标的 next 数组值为4</li><li>p2指针跳转到 match_str[4] 处继续和 orign_str 中的d字符进行匹配<ul><li>match_str[4] ≠ ‘d’，则需要p2指针继续根据 next 数组向前跳转到 p2 = next[4] = 0 进行匹配</li><li>match_str[0] = “1” ≠ ‘d’，此时 next[p2] = -1，表示子串的第一个字符都已经和’d’字符不相等了，则母串的指针p1只能是继续右移了</li></ul></li></ul></li></ul><p>以上过程就是加速的过程，保证了母串的指针p1不会向前跳转，一直向后增长，时间复杂度降到O(N)。</p><ul><li>代码实现：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">const</span> string&amp; orign_str, <span class="keyword">const</span> string&amp; match_str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, len1 = orign_str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>, len2 = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">get_next_arr</span>(match_str);</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (orign_str[p1] == match_str[p2]) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (next[p2] == <span class="number">-1</span>) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = next[p2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2 == len2 ? (p1 - p2) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>问题记录</li></ul><p><img src="/2021/09/25/KMP/Untitled.png" alt="0"></p><ul><li><strong>Q1：为什么在X ≠ Y 的时候要将 match_str 中的 Z 去和 X 比较？</strong><br>X ≠ Y 发生的时候，根据 match_str 的 next 数组可以得知 partA == partB，所以直接舍弃 orign_str 字符串中 J 之前的部分，不再进行比较，直接将逻辑上看着就是直接将 match_str 推送到  orign_str 字符串中 J 位置上，而 partC == partB， 则 partA == partC 无需再比较，直接比较X和Z即可。</li><li><strong>Q2：为什么可以直接抛弃掉 orign_str 字符串中 J 之前的部分？真的不会匹配出一个 match_str 吗？</strong><br>假设这段有一个位置K，从此位置开始可以匹配出一个 match_str，则必然 [K, X] 这一段范围的字符串是存在于match_str中的，因为第一次匹配的时候是一路匹配下来的，按照这样则 match_str 的 next 数组值应该区域更大，和现有的发生矛盾，则证明一定可以抛弃。</li></ul><h3 id="2-2-4-next数组的求解"><a href="#2-2-4-next数组的求解" class="headerlink" title="2.2.4 next数组的求解"></a>2.2.4 next数组的求解</h3><p>前面的next数组的值求取是依赖其位置字符的最大前缀和最大后缀的相同的长度，没有说如何快速生成，一直当作一个黑盒在使用。</p><p>其实 i 位置的值是依赖 i-1 位置的值，所以根据下图得知：</p><p><img src="/2021/09/25/KMP/Untitled_1.png" alt="1"></p><p>求取 i 位置的值，只需要判断 b 的 next[] 值的下一个字符即 ？是否和字符 b 相等即可</p><ul><li>相等，则next[a] = next[b] + 1</li><li>不等，则前推；若一直推到 index = 0 处还没有相等的，则为 0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_next_arr</span><span class="params">(<span class="keyword">const</span> string&amp; match_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">assign</span>(len, <span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (match_str[i - <span class="number">1</span>] == match_str[cn])&#123;</span><br><span class="line">            next[i++] = ++cn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-完整代码测试"><a href="#2-2-5-完整代码测试" class="headerlink" title="2.2.5 完整代码测试"></a>2.2.5 完整代码测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">get_next_arr</span><span class="params">(<span class="keyword">const</span> string&amp; match_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">    next.<span class="built_in">assign</span>(len, <span class="number">0</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (match_str[i - <span class="number">1</span>] == match_str[cn])&#123;</span><br><span class="line">            next[i++] = ++cn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">const</span> string&amp; orign_str, <span class="keyword">const</span> string&amp; match_str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, len1 = orign_str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>, len2 = match_str.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">get_next_arr</span>(match_str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;next arr value: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n---------------\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (orign_str[p1] == match_str[p2]) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (next[p2] == <span class="number">-1</span>) &#123;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = next[p2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2 == len2 ? (p1 - p2) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string orign_str = <span class="string">&quot;1234abc1234defk1234abc1234xyz789&quot;</span>;</span><br><span class="line">    string match_str = <span class="string">&quot;1234abc1234xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">get_index</span>(orign_str, match_str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;match_str in orign_str index: &quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2021/09/25/KMP/Untitled_2.png" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;p&gt;KMP算法的用处是为了加快&lt;strong&gt;子串match_str&lt;/strong&gt;在&lt;strong&gt;母串orign_st</summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-String" scheme="https://ryanxw24.github.io/tags/algo-String/"/>
    
  </entry>
  
  <entry>
    <title>二分查找应用2</title>
    <link href="https://ryanxw24.github.io/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A82/"/>
    <id>https://ryanxw24.github.io/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A82/</id>
    <published>2021-09-19T07:05:57.000Z</published>
    <updated>2022-02-20T07:14:43.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p><ul><li>要求：时间复杂度为 O(log n)   </li><li>例子：<ul><li>输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]</li><li>输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1]</li></ul></li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode链接</a></li></ul><h1 id="解法：改写二分"><a href="#解法：改写二分" class="headerlink" title="解法：改写二分"></a>解法：改写二分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindLeft</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindRight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">FindLeft</span>(nums, target);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">FindRight</span>(nums, target);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">    ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 t</summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-BinarySearch" scheme="https://ryanxw24.github.io/tags/algo-BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>二分查找应用1</title>
    <link href="https://ryanxw24.github.io/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A81/"/>
    <id>https://ryanxw24.github.io/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A81/</id>
    <published>2021-09-19T06:46:28.000Z</published>
    <updated>2022-02-20T07:05:45.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><ul><li>要求：时间复杂度为 O(log n)   </li><li>例子：<ul><li>输入: nums = [1,3,5,6], target = 5    输出: 2</li><li>输入: nums = [1,3,5,6], target = 2    输出: 1</li></ul></li><li><a href="https://leetcode-cn.com/problems/search-insert-position/">leetcode链接</a><h1 id="解法：改写二分"><a href="#解法：改写二分" class="headerlink" title="解法：改写二分"></a>解法：改写二分</h1></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123; <span class="comment">// 用于判断左边界 比如[1,3,5,6] target=0</span></span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-BinarySearch" scheme="https://ryanxw24.github.io/tags/algo-BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>二分查找学习总结</title>
    <link href="https://ryanxw24.github.io/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://ryanxw24.github.io/2021/09/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-09-19T06:01:52.000Z</published>
    <updated>2022-02-20T06:47:06.081Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结二分查找算法，其实该算法的思想是很简单的。即在有序的线性存储结构中进行查找。</p><blockquote><ol><li>选择<code>mid</code>位置的元素<code>x</code>是否等于<code>target</code>，相等则终止查找；</li><li>若<code>x &lt; target</code>则需要向右半区间查找，更新<strong>左</strong>边界；</li><li>若<code>x &gt; target</code>则需要向左半区间查找，更新<strong>右</strong>边界;</li><li>重复前面几步直到不能再划分为止。</li></ol></blockquote><h1 id="1-关键点：查询的边界确定问题"><a href="#1-关键点：查询的边界确定问题" class="headerlink" title="1. 关键点：查询的边界确定问题"></a>1. 关键点：查询的边界确定问题</h1><p><strong>循环不变量的确定</strong>：即每次查询的左右区间维持一致，确保查询不重不漏</p><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><ul><li>左闭右闭写法 <strong>[left, right]</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len - <span class="number">1</span>;    <span class="comment">// key：决定了[l, r]查找</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123; <span class="comment">// 需要更新左边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123; <span class="comment">// 需要更新右边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>左闭右开写法 <strong>[left, right)</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len;    <span class="comment">// key：决定了[l, r)查找</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文总结二分查找算法，其实该算法的思想是很简单的。即在有序的线性存储结构中进行查找。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;选择&lt;code&gt;mid&lt;/code&gt;位置的元素&lt;code&gt;x&lt;/code&gt;是否等于&lt;code&gt;target&lt;/code&gt;，相等则终止查找</summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-BinarySearch" scheme="https://ryanxw24.github.io/tags/algo-BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试学习总结</title>
    <link href="https://ryanxw24.github.io/2021/09/15/GDB/"/>
    <id>https://ryanxw24.github.io/2021/09/15/GDB/</id>
    <published>2021-09-14T17:08:24.000Z</published>
    <updated>2022-02-20T05:59:52.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB调试学习总结"><a href="#GDB调试学习总结" class="headerlink" title="GDB调试学习总结"></a>GDB调试学习总结</h1><h2 id="命令概览"><a href="#命令概览" class="headerlink" title="命令概览"></a>命令概览</h2><table><thead><tr><th>命令名称</th><th>命令缩写</th><th>命令说明</th><th>备注</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行一个程序</td><td></td></tr><tr><td>break</td><td>b</td><td>添加断点</td><td>-b xx.cpp:line</td></tr><tr><td>delete</td><td>del</td><td>删除断点</td><td></td></tr><tr><td>list</td><td>l</td><td>显示源代码</td><td></td></tr><tr><td>continue</td><td>c</td><td>让暂停的程序继续运行</td><td></td></tr><tr><td>next</td><td>n</td><td>运行到下一行源代码，不进入函数内部</td><td></td></tr><tr><td>step</td><td>s</td><td>运行到下一行源代码，进入函数内部</td><td></td></tr><tr><td>print</td><td>p</td><td>打印变量或者寄存器的值</td><td></td></tr><tr><td>until</td><td>u</td><td>运行到指定行停止下来</td><td></td></tr><tr><td>jump</td><td>j</td><td>将当前程序执行流跳转到指定行或地址</td><td></td></tr><tr><td>backtrace</td><td>bt</td><td>查看当前线程的调用堆栈</td><td></td></tr><tr><td>thread</td><td>thread</td><td>切换到指定线程</td><td></td></tr><tr><td>frame</td><td>f</td><td>切换到当前调用线程的指定堆栈,具体堆栈通过堆栈序号指定</td><td></td></tr><tr><td>info</td><td>info</td><td>查看断点/线程等信息</td><td></td></tr><tr><td>ptype</td><td>ptype</td><td>查看变量类型</td><td></td></tr><tr><td>disassemble</td><td>dis</td><td>查看汇编代码</td><td></td></tr><tr><td>watch</td><td>watch</td><td>监视某一个变量或内存地址的值是否发生变化</td><td></td></tr><tr><td>finish</td><td>fin</td><td>结束当前调用函数，返回到上一层函数调用处</td><td></td></tr><tr><td>return</td><td>return</td><td>结束当前调用函数并返回指定值，到上一层函数调用处</td><td></td></tr></tbody></table><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><h3 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h3><ul><li><code>gdb filename</code><br>开发过程中，编译生成目标二进制文件后，可以直接<code>gdb filename</code>开始调试，输入<code>run</code>或<code>r</code>运行程序。比如下图所示：<br>  <img src="/2021/09/15/GDB/gdb1.png" alt="gdb1"><br>启动后可以通过<code>netstat -nltp | grep 6379</code>来查看程序已经运行起来了<br>  <img src="/2021/09/15/GDB/gdb2.png" alt="gdb2"></li></ul><h3 id="附加进程调试"><a href="#附加进程调试" class="headerlink" title="附加进程调试"></a>附加进程调试</h3><ul><li><code>gdb attach pid</code><br>如果当程序已经启动后想调试，但是不想重启程序。或者当程序在测试过程中，不能重启，一旦重启则会丢失当前的状态信息。这种情况下就使用附加进程进行调试。<ul><li>获取进程pid<br><img src="/2021/09/15/GDB/gdb3.png" alt="gdb3"></li><li>生成附加进程<br><img src="/2021/09/15/GDB/gdb4.png" alt="gdb4"><br>提示 “Attaching to process 8380 时即已成功将 GDB 附加到目标进程，结束调试后输入<code>detach</code>离开且不对当前进程有影响，让程序和gdb调试器分离，如下图：<br><img src="/2021/09/15/GDB/gdb5.png" alt="gdb5"></li></ul></li></ul><h3 id="core文件调试"><a href="#core文件调试" class="headerlink" title="core文件调试"></a>core文件调试</h3><p>coredump即核心转储，是进程运行崩溃瞬间的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存到core文件，该文件是个二进制文件，可以使用gdb进行分析。</p><ul><li><p>产生原因</p><ul><li>内存访问越界</li><li>多线程程序使用了线程不安全的函数</li><li>多线程读写数据未加锁保护，对于被多个线程同时访问的全局数据，要加锁保护否则会coredump</li><li>非法指针</li><li>堆栈溢出</li></ul></li><li><p>查看系统产生core文件后存放的位置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[xw@null coredump]$ cat /proc/sys/kernel/core_pattern </span><br><span class="line">/data/coredump/core_%e_%t</span><br><span class="line">- 表示产生的core文件都以core_%e_%t格式保存到/data/coredump/目录下</span><br><span class="line">-e 程序文件名</span><br><span class="line">-t 时间戳</span><br><span class="line">-p 进程ID</span><br><span class="line">-s 使进程崩溃的信号signal</span><br></pre></td></tr></table></figure></li><li><p>修改core文件的存储位置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/data/coredump/core_%e_%t&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></li><li><p>修改core文件大小<br>  (1) ulimit -c 查看参数core file size的值，如果为0表示不会生成core文件，一般修改为unlimited</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xw@null ~]$ ulimit -c</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>  (2) 修改core文件大小</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xw@null ~]$ ulimit -c unlimited</span><br><span class="line">[xw@null ~]$ ulimit -c</span><br><span class="line">unlimited</span><br></pre></td></tr></table></figure></li><li><p><code>readelf -h corefile</code>查看core文件头<br>  <img src="/2021/09/15/GDB/core8.png" alt="core8"></p></li><li><p>gdb调试core文件</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb 执行文件 core文件</span><br><span class="line">where/bt 查看堆栈信息进一步分析程序</span><br></pre></td></tr></table></figure></li><li><p>参考链接</p><ul><li><a href="https://zhuanlan.zhihu.com/p/98700797">linux coredump调试</a></li><li><a href="https://zhuanlan.zhihu.com/p/46605905">gdb调试coredump</a></li><li><a href="https://zhuanlan.zhihu.com/p/199841770">linux上创建并调试转储文件</a></li></ul></li></ul><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xxxx@gzqc-172_24_21_96-null src]$ gdb redis-server</span><br></pre></td></tr></table></figure><p><img src="/2021/09/15/GDB/gdb6.png" alt="gdb6"><br>此时只是附加了一个调试文件，程序还未启动，输入<code>run</code>命令即可运行程序。<br><img src="/2021/09/15/GDB/gdb7.png" alt="gdb7"><br>按<code>Ctrl+C</code>可以中断<code>gdb</code>,再次输入<code>r</code>后输入<code>y</code>重启程序<br><img src="/2021/09/15/GDB/gdb8.png" alt="gdb8"></p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>按<code>Ctrl+C</code>可以中断<code>gdb</code>,输入<code>c</code>可以使程序继续运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff71e9d43 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><ul><li><p><code>break</code>用于添加断点，添加完成后重启程序即可触发，停在断点处</p><ul><li><code>break func</code>在函数名入口处添加断点 </li><li><code>break line</code>在当前文件行号line处添加断点</li><li><code>break filename:line</code>在文件filename行号line处添加断点<br><img src="/2021/09/15/GDB/gdb9.png" alt="gdb9"></li></ul></li><li><p>redis-server端口<code>6379</code>，端口号肯定是通过<code>bind()</code>函数创建的，搜索文件位于<code>anet.c 401 </code>行。<br>  <img src="/2021/09/15/GDB/gdb10.png" alt="gdb10"></p><ul><li>在<code>anet.c:401</code>处添加断点后重启触发断点<code>1</code>, <code>continue</code>后触发断点<code>2</code>。如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b anet.c:401</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /data/home/xxxx/redis-6.2.3/src/redis-server </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.</span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdf58) at server.c:6151</span><br><span class="line">6151        char config_from_stdin = 0;</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 2, anetListen (err=0xbcee50 &lt;server+752&gt; &quot;&quot;, s=10, sa=0xdf79a0, len=16, backlog=511) at anet.c:401</span><br><span class="line">401         if (bind(s,sa,len) == -1) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>分别在<code>anet.c 404 410 412</code>处添加断点，用于判断从该函数从何处返回。如下图所示：<br><img src="/2021/09/15/GDB/gdb12.png" alt="gdb12"></li><li><code>continue</code>可以看到触发断点<code>5</code>。如下图所示：<br><img src="/2021/09/15/GDB/gdb13.png" alt="gdb13"></li></ul></li></ul><h3 id="backtrace-和-frame"><a href="#backtrace-和-frame" class="headerlink" title="backtrace 和 frame"></a>backtrace 和 frame</h3><ul><li><p><code>backtrace</code>用于查看堆栈信息。<code>frame</code>用于切换到某个堆栈处。上面的gdb程序中断在<code>anet.c:412</code>处</p><ul><li><p><code>bt</code>查看此时的堆栈信息共有6层堆栈<code>#0 ~ #5</code>，如下图所示：<br><img src="/2021/09/15/GDB/gdb15.png" alt="gdb15"></p></li><li><p><code>frame 堆栈编号</code>切换堆栈信息，如下图所示：<br><img src="/2021/09/15/GDB/gdb14.png" alt="gdb14"><br>  可以得到调用关系</p><ul><li><code>main()</code>函数在6322行调用<code>initServer()</code>函数</li><li><code>initServer()</code>函数在3195行调用<code>listenToPort()</code>函数</li><li><code>listenToPort()</code>函数在3052行调用<code>anetTcpServer()</code>函数</li><li><code>anetTcpServer()</code>函数在468行调用<code>_anetTcpServer()</code>函数</li><li><code>_anetTcpServer()</code>函数在450行调用<code>anetListen()</code>函数</li><li>此时断点正停在<code>anetListen()</code>函数中</li></ul></li></ul></li></ul><h3 id="info-break、enable、disable、delete"><a href="#info-break、enable、disable、delete" class="headerlink" title="info break、enable、disable、delete"></a>info break、enable、disable、delete</h3><ul><li><code>info b</code>查看断点个数<br>  <img src="/2021/09/15/GDB/gdb16.png" alt="gdb16"></li><li><code>enable num</code>启用编号为num的断点，不加参数表示全部启用</li><li><code>disable num</code>禁用编号为num的断点，不加参数表示全部禁用</li><li><code>delete num</code>删除编号为num的断点，不加参数表示全部删除  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">3       breakpoint     keep y   0x000000000043412c in anetListen at anet.c:404</span><br><span class="line">4       breakpoint     keep y   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) disable 4</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">3       breakpoint     keep y   0x000000000043412c in anetListen at anet.c:404</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) delete 3</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) disable </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep n   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep n   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep n   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) enable </span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000442962 in main at server.c:6151</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x00000000004340e2 in anetListen at anet.c:401</span><br><span class="line">        breakpoint already hit 2 times</span><br><span class="line">4       breakpoint     keep y   0x0000000000434178 in anetListen at anet.c:410</span><br><span class="line">5       breakpoint     keep y   0x000000000043417f in anetListen at anet.c:412</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">(gdb) delete </span><br><span class="line">Delete all breakpoints? (y or n) y       </span><br><span class="line">(gdb) info b</span><br><span class="line">No breakpoints or watchpoints.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul><li><code>list</code>用于显示源码，默认显示10行。如图所示：<br>  <img src="/2021/09/15/GDB/gdb17.png" alt="gdb17"></li></ul><h3 id="print、ptype"><a href="#print、ptype" class="headerlink" title="print、ptype"></a>print、ptype</h3><ul><li><code>print</code>用于查看变量的值，<code>ptype</code>用于查看变量类型。如下所示：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 4</span><br><span class="line">#4  0x000000000043b304 in initServer () at server.c:3195</span><br><span class="line">3195            listenToPort(server.port,&amp;server.ipfd) == C_ERR) &#123;</span><br><span class="line">(gdb) p server.port</span><br><span class="line">$1 = 6379</span><br><span class="line">(gdb) ptype server</span><br><span class="line">type = struct redisServer &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pthread_t main_thread_id;</span><br><span class="line">    char *configfile;</span><br><span class="line">    char *executable;</span><br><span class="line">    char **exec_argv;</span><br><span class="line">    int dynamic_hz;</span><br><span class="line">    int config_hz;</span><br><span class="line">    mode_t umask;</span><br><span class="line">    ....&#125;</span><br><span class="line">(gdb) ptype server.port</span><br><span class="line">type = int</span><br></pre></td></tr></table></figure></li></ul><h3 id="info-和-thread"><a href="#info-和-thread" class="headerlink" title="info 和 thread"></a>info 和 thread</h3><ul><li><p><code>info thread</code>查看<code>redis-server</code>启动后一共产生<code>5</code>个线程，<code>1</code>个主线程和<code>4</code>个工作线程。主线程阻塞在<code>epoll_wait()</code>处，其他工作线程阻塞在<code>pthread_cond_wait()</code>处。<code>*</code>表示的是当前<code>gdb</code>作用于哪个线程上，而不是<code>*</code>就代表指向主线程。<br>  <img src="/2021/09/15/GDB/gdb18.png" alt="gdb18"></p></li><li><p><code>bt</code>查看当前线程的调用堆栈，如下图所示：<br>  <img src="/2021/09/15/GDB/gdb19.png" alt="gdb19"><br>堆栈#4上显示的调用<code>main()</code>函数表示当前线程即主线程。</p></li></ul><ul><li><code>thread num</code>切换到其他线程<br>  <img src="/2021/09/15/GDB/gdb20.png" alt="gdb20"></li></ul><h3 id="next-和-step"><a href="#next-和-step" class="headerlink" title="next 和 step"></a>next 和 step</h3><ul><li><code>next</code>单步步过(step over)，遇到函数直接跳过不会进入函数内部。(回车键默认是将最近的一条命令执行)</li><li><code>step</code>单步步入(step into)，遇到函数进入函数内部。</li></ul><h3 id="until-和-jump"><a href="#until-和-jump" class="headerlink" title="until 和 jump"></a>until 和 jump</h3><ul><li><code>until</code>可以指定程序运行到某一行停下来。</li><li><code>jump</code>可以指定程序执行流跳转到指定位置执行，若跳转的地方没有断点则会继续执行，可以用于测试异常分支代码。</li></ul><h3 id="finish-和-return"><a href="#finish-和-return" class="headerlink" title="finish 和 return"></a>finish 和 return</h3><ul><li><code>finish</code>命令会执行函数到正常退出该函数。</li><li><code>return</code>命令是立即结束执行当前函数并返回，即使当前函数还有剩余的代码未执行完毕，也不会执行。</li></ul><h3 id="disassemble"><a href="#disassemble" class="headerlink" title="disassemble"></a>disassemble</h3><ul><li><code>disassemble</code>命令查看汇编代码，一般用于高级调试选哟查看某段代码的汇编指令，或调试没有调式信息的发版程序。<br>  <img src="/2021/09/15/GDB/gdb21.png" alt="gdb21"></li></ul><h3 id="set-args-和-show-args"><a href="#set-args-和-show-args" class="headerlink" title="set args 和 show args"></a>set args 和 show args</h3><ul><li><code>set args</code>用于传递命令行参数。做法：<code>gdb</code>附加程序，在<code>run</code>之前，使用<code>set args 参数内容</code>来传递命令行参数。</li><li><code>show args</code>用于查看命令行参数是否设置成功。<br>  <img src="/2021/09/15/GDB/gdb22.png" alt="gdb22"></li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>用于监视一个变量或者一段内存，当其值发生变化时，<code>gdb</code>会中断下来。被监视的变量或内存会产生一个<code>watch point</code>(观察点)。</p><ul><li><p>watch命令时通过添加硬件断点来实现监视数据变化，格式：<code>watch 变量名/内存地址</code>。</p><ul><li><p>整形变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">watch i</span><br></pre></td></tr></table></figure></li><li><p>指针类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p;</span><br><span class="line">watch p </span><br><span class="line">watch *p</span><br></pre></td></tr></table></figure></li><li><p>数组/内存区间（这里是对buf的128个数据监视，不是采用硬件中断，是用软中断实现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[10];</span><br><span class="line">watch buf</span><br></pre></td></tr></table></figure></li><li><p>程序例子，可见<code>watch</code>的变量<code>a</code>的值在发生变化时会中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    while (a &lt;= 5)</span><br><span class="line">    &#123;</span><br><span class="line">        a = a*2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/09/15/GDB/gdb23.png" alt="gdb23"></p></li></ul></li></ul><h3 id="多进程-线程调试"><a href="#多进程-线程调试" class="headerlink" title="多进程/线程调试"></a>多进程/线程调试</h3><ul><li><p>调试父子进程</p><ul><li><code>gdb</code>调试父进程，等子进程<code>fork</code>完成后，使用<code>gdb attach pid</code>进入子进程，需要重新开启一个窗口用于调试。</li><li><code>gdb</code>调试器提供选项<code>follow-fork</code>，可以使用<code>show follow-fork mode</code>查看当前值，也可以通过<code>set follow-fork mode</code>来设置是当一个进程<code>fork</code>出新的子进程时，<code>gdb</code>时继续调试父进程还是子进程（取值<code>child</code>），默认是父进程（取值<code>parent</code>）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show follow-fork mode     </span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;parent&quot;.</span><br><span class="line">(gdb) set follow-fork child</span><br><span class="line">(gdb) show follow-fork mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;child&quot;.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></li><li><p>spp 线程</p><ul><li>在<code>tool</code>目录下将服务停止</li><li>进入<code>bin</code>目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./spp_xxx_proxy ../etc/spp_proxy.xml</span><br><span class="line">gdb --args ./spp_xxx_worker ../etc/spp_worker1.xml</span><br><span class="line">set follow-fork-mode child</span><br><span class="line">b 设置断点</span><br><span class="line">r 运行程序</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GDB调试学习总结&quot;&gt;&lt;a href=&quot;#GDB调试学习总结&quot; class=&quot;headerlink&quot; title=&quot;GDB调试学习总结&quot;&gt;&lt;/a&gt;GDB调试学习总结&lt;/h1&gt;&lt;h2 id=&quot;命令概览&quot;&gt;&lt;a href=&quot;#命令概览&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CPP" scheme="https://ryanxw24.github.io/categories/CPP/"/>
    
    
    <category term="GDB" scheme="https://ryanxw24.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法总结</title>
    <link href="https://ryanxw24.github.io/2021/09/13/sort/"/>
    <id>https://ryanxw24.github.io/2021/09/13/sort/</id>
    <published>2021-09-13T11:03:22.000Z</published>
    <updated>2022-02-20T05:41:12.704Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍的几种排序算法的时间复杂度、额外空间复杂度、稳定性如下：</p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>bubble</td><td>O(n^2)</td><td>O(1)</td><td>yes</td></tr><tr><td>insert</td><td>O(n^2)</td><td>O(1)</td><td>yes</td></tr><tr><td>select</td><td>O(n^2)</td><td>O(1)</td><td>no</td></tr><tr><td>merge</td><td>O(n*logn)</td><td>O(n)</td><td>yes</td></tr><tr><td>heap</td><td>O(n*logn)</td><td>O(1)</td><td>no</td></tr><tr><td>quick</td><td>O(n*logn)</td><td>O(n*logn)</td><td>no</td></tr></tbody></table><p>稳定性概念：保证集合中的元素在排序后的相对次序和排序前为一致则是稳定的。例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[a1, b1, a2, a3, c5]</span><br><span class="line">排序顺序：[a1, a2, a3, b1, c5]</span><br><span class="line">其中三个a类型的相对次序没有发生变化则表示是稳定的。</span><br></pre></td></tr></table></figure><h1 id="1-bubble-sort"><a href="#1-bubble-sort" class="headerlink" title="1. bubble sort"></a>1. bubble sort</h1><ul><li>原理：每一轮将该集合的元素中最大的一个沉底即可。</li><li>例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">  第<span class="number">1</span>轮：实现将最大的<span class="number">8</span>放到最后一个位置</span><br><span class="line">  [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>]</span><br><span class="line">  </span><br><span class="line">  第<span class="number">2</span>轮：实现将最大的<span class="number">7</span>放到倒数第<span class="number">2</span>个位置</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">8</span>] -&gt;</span><br><span class="line">  [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">  以此类推，若集合的大小是n，则需要进行n轮，每轮比较n次</span><br><span class="line">  则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li>实现：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-insert-sort"><a href="#2-insert-sort" class="headerlink" title="2. insert sort"></a>2. insert sort</h1><ul><li>原理：将<code>index = 0</code>的位置看作是一个有序区，之后将后续的元素按照大小插入到有序区对应的位置即可。</li><li>例子：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    第<span class="number">1</span>轮：[<span class="number">7</span>]是有序区</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    第<span class="number">2</span>轮：[<span class="number">6</span>, <span class="number">7</span>]是有序区</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">3</span>轮：[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]是有序区</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    以此类推，若集合的大小是n，则需要进行n轮，</span><br><span class="line">    比较的次数是一个等差数列的和，则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li>实现：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-select-sort"><a href="#3-select-sort" class="headerlink" title="3. select sort"></a>3. select sort</h1></li><li>原理：从元素中找出最小的数放到集合的<code>index=0</code>的位置，之后轮询n次每次将最小的数放到有序集合后面即可。</li><li>例子：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    第<span class="number">1</span>轮：选择最小的元素<span class="number">0</span>放到起始位置</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>] </span><br><span class="line">    </span><br><span class="line">    以此类推，若集合大小是n，则需要进行n轮，</span><br><span class="line">    比较的次数是一个等差数列的和，则时间复杂度为<span class="built_in">O</span>(n^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li>实现：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-merge-sort"><a href="#4-merge-sort" class="headerlink" title="4. merge sort"></a>4. merge sort</h1></li><li>原理：不停的将集合二分（逻辑上的划分），直到元素不能再划分为止，则申请对应的空间按相对大小填充返回即可。</li><li>例子：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">    第<span class="number">1</span>轮：以 index = <span class="number">2</span> 开始划分</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]  [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">2</span>轮：将第<span class="number">1</span>轮的集合左右各自继续划分</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>] [<span class="number">4</span>] [<span class="number">5</span>, <span class="number">3</span>] [<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">3</span>轮：将第<span class="number">2</span>轮中可以划分的继续划分</span><br><span class="line">    [<span class="number">2</span>] [<span class="number">1</span>] [<span class="number">4</span>] [<span class="number">5</span>] [<span class="number">3</span>] [<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    第<span class="number">4</span>轮：按照划分好的结果通过大小逆序向上合并填充即可</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>] [<span class="number">4</span>] [<span class="number">3</span>, <span class="number">5</span>] [<span class="number">6</span>] -&gt;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>] -&gt; </span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li><li>实现：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(a, l, mid, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> help[len];</span><br><span class="line">    <span class="keyword">int</span> help_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">        help[help_idx++] = a[p1] &lt; a[p2] ? a[p1++] : a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">         help[help_idx++] = a[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)&#123;</span><br><span class="line">         help[help_idx++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        a[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>应用：<ul><li>小和问题：每个位置上左边有比该位置值小的所有的数的和。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[2, 1, 4, 5, 3, 6]</span><br><span class="line">small_sum = (2 + 1) + </span><br><span class="line">            (2 + 1 + 4) + </span><br><span class="line">            (2 + 1) + </span><br><span class="line">            (1 + 2 + 3 + 4 + 5)</span><br><span class="line">在 merge 的过程中就可以计算出所有小和</span><br><span class="line">a[i] &lt; a[j] 则出现的次数总和为：(r - j + 1) * a[i]</span><br></pre></td></tr></table></figure></li><li>逆序对：每个位置右边有比该位置数小的数对个数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[2, 1, 4, 5, 3, 6]</span><br><span class="line">逆序对个数：</span><br><span class="line">[2, 1]</span><br><span class="line">[4, 3]</span><br><span class="line">[5, 3]</span><br><span class="line">在 merge 的过程中可以求取逆序对个数：</span><br><span class="line">a[i] &gt; a[j] 则逆序对的个数为：(mid - i + 1)</span><br></pre></td></tr></table></figure><h1 id="5-heap-sort"><a href="#5-heap-sort" class="headerlink" title="5. heap sort"></a>5. heap sort</h1></li></ul></li><li>原理：堆排的实现对应算法中的优先级队列，核心分为2步：<strong>建堆</strong>和<strong>调堆</strong><ul><li><p><strong>建堆</strong>：通过比较当前位置的树是否比起父节点大的方法来创建一个大根堆（以该节点为根的树是该节点是最大值）。建堆只需要在数组上调整即可，逻辑上对应的是一棵完全二叉树，时间复杂度为<code>O(n)</code>。<br>关注两点：</p><blockquote><p>父节点<code>index = i</code>，左右孩子节点<code>left = 2*i + 1, right = 2*i + 2</code>；<br>孩子节点<code>index = i</code>，父节点<code>fa = (i - 1) / 2</code></p></blockquote></li><li><p><strong>调堆</strong>：将堆的根节点调到最后一个叶子节点处（即数组的最后一个位置），剪枝，之后从根节点进行元素调整继续维护为一个大根堆的样子便于下次取到最大值元素，该操作的时间复杂度为<code>O(n*logn)</code></p></li></ul></li><li>例子：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">step1: 建堆，判断当前位置的数是否比其父亲节点大，若大则交换，则index从<span class="number">0</span>到N扫描，第i个节点树的高度为<span class="built_in">log</span>(i)</span><br><span class="line">则<span class="built_in">T</span>(N) = <span class="built_in">log</span>(<span class="number">1</span>) + <span class="built_in">log</span>(<span class="number">2</span>) + ... + <span class="built_in">log</span>(N) 可以在<span class="built_in">O</span>(N)内收敛</span><br><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">step2: 调堆 <span class="built_in">O</span>(N * logN)</span><br><span class="line">将<span class="number">7</span>置换到数组末尾进行剪枝后再进行调堆</span><br><span class="line">[<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] -&gt;</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, (<span class="number">7</span>)] -&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, (<span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line">以此类推直到取完最后一个节点为止即可</span><br></pre></td></tr></table></figure></li><li>例子示例图：<ul><li>建堆图：<!-- ![](./sort/建堆过程.png)  该形式是在预览时使用 --><!-- ![](建堆过程.png)  该形式是在部署时使用--><img src="/2021/09/13/sort/%E5%BB%BA%E5%A0%86%E8%BF%87%E7%A8%8B.png"> </li><li>剪枝调堆图：<br><img src="/2021/09/13/sort/%E5%89%AA%E6%9E%9D%E8%B0%83%E5%A0%86.png"></li></ul></li><li>实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="built_in">heapInsert</span>(a, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = len;</span><br><span class="line">    <span class="built_in">swap</span>(a[<span class="number">0</span>], a[--size]);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="built_in">swap</span>(a[<span class="number">0</span>], a[--size]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a[index] &gt; a[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[index], a[(index - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; a[left + <span class="number">1</span>] &gt; a[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = a[largest] &gt; a[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[largest], a[index]);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-quick-sort"><a href="#6-quick-sort" class="headerlink" title="6. quick sort"></a>6. quick sort</h1></li><li>原理：核心<code>partition</code>过程来将数组按照随机选定一个值<code>p</code>将元素划分为<code>&lt;p, =p, &gt;p</code>三个区域，将等于区域返回之后继续递归划分直到不能划分结束。<ul><li>随机选定元素的原因：从规模上减少每次选择的划分值不好，增大递归的规模，从而使时间复杂度退化为<code>O(n^2)</code>。</li><li>递归划分时每次都选择中间值，则递归规模每次为<code>n/2</code>，根据<code>master</code>公式可以得知<code>T(N) = 2 * T(N / 2) + O(N^1)</code>，则时间复杂度收敛到<code>O(N*logN)</code>。</li></ul></li><li>例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">  step1: 假设随机选取划分值p = <span class="number">4</span></span><br><span class="line">  step2: partition过程，根据p = <span class="number">4</span>进行划分，该过程时间复杂度<span class="built_in">O</span>(N)</span><br><span class="line">      a[i] &lt; p 时则小于区域扩大，小于区的下一个元素和a[i]交换，同时i自增</span><br><span class="line">      a[i] = p 时则等于区扩大，i自增</span><br><span class="line">      a[i] &gt; p 时则i保持不变，大于区前一个数和a[i]交换，大于区扩大</span><br><span class="line">    [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>] -&gt;</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">  step3：将partition过程等于区域的index数组[<span class="number">3</span>, <span class="number">3</span>]返回用于下一次递归即可</span><br><span class="line"></span><br><span class="line">  额外空间复杂度 <span class="built_in">O</span>(N*logN)，用于保存partition过程中树的节点</span><br></pre></td></tr></table></figure></li><li>实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> r_index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[r_index], a[r]);</span><br><span class="line">        <span class="keyword">int</span> *parr = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">        <span class="built_in">quickSort</span>(a, l, parr[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(a, parr[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">int</span> *parr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> m = l;</span><br><span class="line">    <span class="keyword">while</span> (m &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[m] &lt; a[r])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[++less], a[m++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[m] == a[r])&#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[m], a[--more]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[r], a[more]);</span><br><span class="line">    parr[<span class="number">0</span>] = less + <span class="number">1</span>;</span><br><span class="line">    parr[<span class="number">1</span>] = more;</span><br><span class="line">    <span class="keyword">return</span> parr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>master公式普及<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>(N) = a * <span class="built_in">T</span>(N / b) + <span class="built_in">O</span>(N^d)</span><br><span class="line">(<span class="number">1</span>) <span class="built_in">logb</span>(a) = d 则 <span class="built_in">T</span>(N) = N^d * <span class="built_in">logN</span></span><br><span class="line">(<span class="number">2</span>) <span class="built_in">logb</span>(a) &gt; d 则 <span class="built_in">T</span>(N) = N^<span class="built_in">logb</span>(a)</span><br><span class="line">(<span class="number">3</span>) <span class="built_in">logb</span>(a) &lt; d 则 <span class="built_in">T</span>(N) = N^d</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍的几种排序算法的时间复杂度、额外空间复杂度、稳定性如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;排序算法&lt;/th&gt;
&lt;th&gt;平均时间复杂度&lt;/th&gt;
&lt;th&gt;额外空间复杂度&lt;/th&gt;
&lt;th&gt;稳定性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tb</summary>
      
    
    
    
    <category term="algorithm" scheme="https://ryanxw24.github.io/categories/algorithm/"/>
    
    
    <category term="algo-sort" scheme="https://ryanxw24.github.io/tags/algo-sort/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ryanxw24.github.io/2021/09/12/hello/"/>
    <id>https://ryanxw24.github.io/2021/09/12/hello/</id>
    <published>2021-09-11T17:08:24.000Z</published>
    <updated>2022-02-20T06:02:23.818Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hexo" scheme="https://ryanxw24.github.io/categories/hexo/"/>
    
    
    <category term="hello world" scheme="https://ryanxw24.github.io/tags/hello-world/"/>
    
  </entry>
  
</feed>
